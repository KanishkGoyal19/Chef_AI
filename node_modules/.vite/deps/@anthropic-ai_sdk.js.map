{
  "version": 3,
  "sources": ["../../@anthropic-ai/sdk/src/version.ts", "../../@anthropic-ai/sdk/src/_shims/registry.ts", "../../@anthropic-ai/sdk/src/_shims/MultipartBody.ts", "../../@anthropic-ai/sdk/src/_shims/web-runtime.ts", "../../@anthropic-ai/sdk/_shims/index.mjs", "../../@anthropic-ai/sdk/src/error.ts", "../../@anthropic-ai/sdk/src/internal/decoders/line.ts", "../../@anthropic-ai/sdk/src/streaming.ts", "../../@anthropic-ai/sdk/src/uploads.ts", "../../@anthropic-ai/sdk/src/core.ts", "../../@anthropic-ai/sdk/src/pagination.ts", "../../@anthropic-ai/sdk/src/resource.ts", "../../@anthropic-ai/sdk/src/resources/beta/models.ts", "../../@anthropic-ai/sdk/src/internal/decoders/jsonl.ts", "../../@anthropic-ai/sdk/src/resources/beta/messages/batches.ts", "../../@anthropic-ai/sdk/src/resources/beta/messages/messages.ts", "../../@anthropic-ai/sdk/src/resources/beta/beta.ts", "../../@anthropic-ai/sdk/src/resources/completions.ts", "../../@anthropic-ai/sdk/src/resources/messages/batches.ts", "../../@anthropic-ai/sdk/src/_vendor/partial-json-parser/parser.ts", "../../@anthropic-ai/sdk/src/lib/MessageStream.ts", "../../@anthropic-ai/sdk/src/resources/messages/messages.ts", "../../@anthropic-ai/sdk/src/resources/models.ts", "../../@anthropic-ai/sdk/src/index.ts"],
  "sourcesContent": ["export const VERSION = '0.33.1'; // x-release-please-version\r\n", "/**\r\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\r\n */\r\nimport { type RequestOptions } from \"../core.js\";\r\n\r\nexport interface Shims {\r\n  kind: string;\r\n  fetch: any;\r\n  Request: any;\r\n  Response: any;\r\n  Headers: any;\r\n  FormData: any;\r\n  Blob: any;\r\n  File: any;\r\n  ReadableStream: any;\r\n  getMultipartRequestOptions: <T = Record<string, unknown>>(\r\n    form: Shims['FormData'],\r\n    opts: RequestOptions<T>,\r\n  ) => Promise<RequestOptions<T>>;\r\n  getDefaultAgent: (url: string) => any;\r\n  fileFromPath:\r\n    | ((path: string, filename?: string, options?: {}) => Promise<Shims['File']>)\r\n    | ((path: string, options?: {}) => Promise<Shims['File']>);\r\n  isFsReadStream: (value: any) => boolean;\r\n}\r\n\r\nexport let auto = false;\r\nexport let kind: Shims['kind'] | undefined = undefined;\r\nexport let fetch: Shims['fetch'] | undefined = undefined;\r\nexport let Request: Shims['Request'] | undefined = undefined;\r\nexport let Response: Shims['Response'] | undefined = undefined;\r\nexport let Headers: Shims['Headers'] | undefined = undefined;\r\nexport let FormData: Shims['FormData'] | undefined = undefined;\r\nexport let Blob: Shims['Blob'] | undefined = undefined;\r\nexport let File: Shims['File'] | undefined = undefined;\r\nexport let ReadableStream: Shims['ReadableStream'] | undefined = undefined;\r\nexport let getMultipartRequestOptions: Shims['getMultipartRequestOptions'] | undefined = undefined;\r\nexport let getDefaultAgent: Shims['getDefaultAgent'] | undefined = undefined;\r\nexport let fileFromPath: Shims['fileFromPath'] | undefined = undefined;\r\nexport let isFsReadStream: Shims['isFsReadStream'] | undefined = undefined;\r\n\r\nexport function setShims(shims: Shims, options: { auto: boolean } = { auto: false }) {\r\n  if (auto) {\r\n    throw new Error(\r\n      `you must \\`import '@anthropic-ai/sdk/shims/${shims.kind}'\\` before importing anything else from @anthropic-ai/sdk`,\r\n    );\r\n  }\r\n  if (kind) {\r\n    throw new Error(\r\n      `can't \\`import '@anthropic-ai/sdk/shims/${shims.kind}'\\` after \\`import '@anthropic-ai/sdk/shims/${kind}'\\``,\r\n    );\r\n  }\r\n  auto = options.auto;\r\n  kind = shims.kind;\r\n  fetch = shims.fetch;\r\n  Request = shims.Request;\r\n  Response = shims.Response;\r\n  Headers = shims.Headers;\r\n  FormData = shims.FormData;\r\n  Blob = shims.Blob;\r\n  File = shims.File;\r\n  ReadableStream = shims.ReadableStream;\r\n  getMultipartRequestOptions = shims.getMultipartRequestOptions;\r\n  getDefaultAgent = shims.getDefaultAgent;\r\n  fileFromPath = shims.fileFromPath;\r\n  isFsReadStream = shims.isFsReadStream;\r\n}\r\n", "/**\r\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\r\n */\r\nexport class MultipartBody {\r\n  constructor(public body: any) {}\r\n  get [Symbol.toStringTag](): string {\r\n    return 'MultipartBody';\r\n  }\r\n}\r\n", "/**\r\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\r\n */\r\nimport { MultipartBody } from \"./MultipartBody.js\";\r\nimport { type RequestOptions } from \"../core.js\";\r\nimport { type Shims } from \"./registry.js\";\r\n\r\nexport function getRuntime({ manuallyImported }: { manuallyImported?: boolean } = {}): Shims {\r\n  const recommendation =\r\n    manuallyImported ?\r\n      `You may need to use polyfills`\r\n    : `Add one of these imports before your first \\`import â€¦ from '@anthropic-ai/sdk'\\`:\r\n- \\`import '@anthropic-ai/sdk/shims/node'\\` (if you're running on Node)\r\n- \\`import '@anthropic-ai/sdk/shims/web'\\` (otherwise)\r\n`;\r\n\r\n  let _fetch, _Request, _Response, _Headers;\r\n  try {\r\n    // @ts-ignore\r\n    _fetch = fetch;\r\n    // @ts-ignore\r\n    _Request = Request;\r\n    // @ts-ignore\r\n    _Response = Response;\r\n    // @ts-ignore\r\n    _Headers = Headers;\r\n  } catch (error) {\r\n    throw new Error(\r\n      `this environment is missing the following Web Fetch API type: ${\r\n        (error as any).message\r\n      }. ${recommendation}`,\r\n    );\r\n  }\r\n\r\n  return {\r\n    kind: 'web',\r\n    fetch: _fetch,\r\n    Request: _Request,\r\n    Response: _Response,\r\n    Headers: _Headers,\r\n    FormData:\r\n      // @ts-ignore\r\n      typeof FormData !== 'undefined' ? FormData : (\r\n        class FormData {\r\n          // @ts-ignore\r\n          constructor() {\r\n            throw new Error(\r\n              `file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`,\r\n            );\r\n          }\r\n        }\r\n      ),\r\n    Blob:\r\n      typeof Blob !== 'undefined' ? Blob : (\r\n        class Blob {\r\n          constructor() {\r\n            throw new Error(\r\n              `file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`,\r\n            );\r\n          }\r\n        }\r\n      ),\r\n    File:\r\n      // @ts-ignore\r\n      typeof File !== 'undefined' ? File : (\r\n        class File {\r\n          // @ts-ignore\r\n          constructor() {\r\n            throw new Error(\r\n              `file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`,\r\n            );\r\n          }\r\n        }\r\n      ),\r\n    ReadableStream:\r\n      // @ts-ignore\r\n      typeof ReadableStream !== 'undefined' ? ReadableStream : (\r\n        class ReadableStream {\r\n          // @ts-ignore\r\n          constructor() {\r\n            throw new Error(\r\n              `streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`,\r\n            );\r\n          }\r\n        }\r\n      ),\r\n    getMultipartRequestOptions: async <T = Record<string, unknown>>(\r\n      // @ts-ignore\r\n      form: FormData,\r\n      opts: RequestOptions<T>,\r\n    ): Promise<RequestOptions<T>> => ({\r\n      ...opts,\r\n      body: new MultipartBody(form) as any,\r\n    }),\r\n    getDefaultAgent: (url: string) => undefined,\r\n    fileFromPath: () => {\r\n      throw new Error(\r\n        'The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/anthropics/anthropic-sdk-typescript#file-uploads',\r\n      );\r\n    },\r\n    isFsReadStream: (value: any) => false,\r\n  };\r\n}\r\n", "/**\r\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\r\n */\r\nimport * as shims from './registry.mjs';\r\nimport * as auto from '@anthropic-ai/sdk/_shims/auto/runtime';\r\nif (!shims.kind) shims.setShims(auto.getRuntime(), { auto: true });\r\nexport * from './registry.mjs';\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { castToError, Headers } from \"./core.js\";\r\n\r\nexport class AnthropicError extends Error {}\r\n\r\nexport class APIError<\r\n  TStatus extends number | undefined = number | undefined,\r\n  THeaders extends Headers | undefined = Headers | undefined,\r\n  TError extends Object | undefined = Object | undefined,\r\n> extends AnthropicError {\r\n  /** HTTP status for the response that caused the error */\r\n  readonly status: TStatus;\r\n  /** HTTP headers for the response that caused the error */\r\n  readonly headers: THeaders;\r\n  /** JSON body of the response that caused the error */\r\n  readonly error: TError;\r\n\r\n  readonly request_id: string | null | undefined;\r\n\r\n  constructor(status: TStatus, error: TError, message: string | undefined, headers: THeaders) {\r\n    super(`${APIError.makeMessage(status, error, message)}`);\r\n    this.status = status;\r\n    this.headers = headers;\r\n    this.request_id = headers?.['request-id'];\r\n    this.error = error;\r\n  }\r\n\r\n  private static makeMessage(status: number | undefined, error: any, message: string | undefined) {\r\n    const msg =\r\n      error?.message ?\r\n        typeof error.message === 'string' ?\r\n          error.message\r\n        : JSON.stringify(error.message)\r\n      : error ? JSON.stringify(error)\r\n      : message;\r\n\r\n    if (status && msg) {\r\n      return `${status} ${msg}`;\r\n    }\r\n    if (status) {\r\n      return `${status} status code (no body)`;\r\n    }\r\n    if (msg) {\r\n      return msg;\r\n    }\r\n    return '(no status code or body)';\r\n  }\r\n\r\n  static generate(\r\n    status: number | undefined,\r\n    errorResponse: Object | undefined,\r\n    message: string | undefined,\r\n    headers: Headers | undefined,\r\n  ): APIError {\r\n    if (!status || !headers) {\r\n      return new APIConnectionError({ message, cause: castToError(errorResponse) });\r\n    }\r\n\r\n    const error = errorResponse as Record<string, any>;\r\n\r\n    if (status === 400) {\r\n      return new BadRequestError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 401) {\r\n      return new AuthenticationError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 403) {\r\n      return new PermissionDeniedError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 404) {\r\n      return new NotFoundError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 409) {\r\n      return new ConflictError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 422) {\r\n      return new UnprocessableEntityError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 429) {\r\n      return new RateLimitError(status, error, message, headers);\r\n    }\r\n\r\n    if (status >= 500) {\r\n      return new InternalServerError(status, error, message, headers);\r\n    }\r\n\r\n    return new APIError(status, error, message, headers);\r\n  }\r\n}\r\n\r\nexport class APIUserAbortError extends APIError<undefined, undefined, undefined> {\r\n  constructor({ message }: { message?: string } = {}) {\r\n    super(undefined, undefined, message || 'Request was aborted.', undefined);\r\n  }\r\n}\r\n\r\nexport class APIConnectionError extends APIError<undefined, undefined, undefined> {\r\n  constructor({ message, cause }: { message?: string | undefined; cause?: Error | undefined }) {\r\n    super(undefined, undefined, message || 'Connection error.', undefined);\r\n    // in some environments the 'cause' property is already declared\r\n    // @ts-ignore\r\n    if (cause) this.cause = cause;\r\n  }\r\n}\r\n\r\nexport class APIConnectionTimeoutError extends APIConnectionError {\r\n  constructor({ message }: { message?: string } = {}) {\r\n    super({ message: message ?? 'Request timed out.' });\r\n  }\r\n}\r\n\r\nexport class BadRequestError extends APIError<400, Headers> {}\r\n\r\nexport class AuthenticationError extends APIError<401, Headers> {}\r\n\r\nexport class PermissionDeniedError extends APIError<403, Headers> {}\r\n\r\nexport class NotFoundError extends APIError<404, Headers> {}\r\n\r\nexport class ConflictError extends APIError<409, Headers> {}\r\n\r\nexport class UnprocessableEntityError extends APIError<422, Headers> {}\r\n\r\nexport class RateLimitError extends APIError<429, Headers> {}\r\n\r\nexport class InternalServerError extends APIError<number, Headers> {}\r\n", "import { AnthropicError } from \"../../error.js\";\r\n\r\nexport type Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\r\n\r\n/**\r\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\r\n * reading lines from text.\r\n *\r\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\r\n */\r\nexport class LineDecoder {\r\n  // prettier-ignore\r\n  static NEWLINE_CHARS = new Set(['\\n', '\\r']);\r\n  static NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\r\n\r\n  buffer: string[];\r\n  trailingCR: boolean;\r\n  textDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either \"dom\" or \"node\" types.\r\n\r\n  constructor() {\r\n    this.buffer = [];\r\n    this.trailingCR = false;\r\n  }\r\n\r\n  decode(chunk: Bytes): string[] {\r\n    let text = this.decodeText(chunk);\r\n\r\n    if (this.trailingCR) {\r\n      text = '\\r' + text;\r\n      this.trailingCR = false;\r\n    }\r\n    if (text.endsWith('\\r')) {\r\n      this.trailingCR = true;\r\n      text = text.slice(0, -1);\r\n    }\r\n\r\n    if (!text) {\r\n      return [];\r\n    }\r\n\r\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\r\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\r\n\r\n    // if there is a trailing new line then the last entry will be an empty\r\n    // string which we don't care about\r\n    if (trailingNewline) {\r\n      lines.pop();\r\n    }\r\n\r\n    if (lines.length === 1 && !trailingNewline) {\r\n      this.buffer.push(lines[0]!);\r\n      return [];\r\n    }\r\n\r\n    if (this.buffer.length > 0) {\r\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\r\n      this.buffer = [];\r\n    }\r\n\r\n    if (!trailingNewline) {\r\n      this.buffer = [lines.pop() || ''];\r\n    }\r\n\r\n    return lines;\r\n  }\r\n\r\n  decodeText(bytes: Bytes): string {\r\n    if (bytes == null) return '';\r\n    if (typeof bytes === 'string') return bytes;\r\n\r\n    // Node:\r\n    if (typeof Buffer !== 'undefined') {\r\n      if (bytes instanceof Buffer) {\r\n        return bytes.toString();\r\n      }\r\n      if (bytes instanceof Uint8Array) {\r\n        return Buffer.from(bytes).toString();\r\n      }\r\n\r\n      throw new AnthropicError(\r\n        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`,\r\n      );\r\n    }\r\n\r\n    // Browser\r\n    if (typeof TextDecoder !== 'undefined') {\r\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\r\n        this.textDecoder ??= new TextDecoder('utf8');\r\n        return this.textDecoder.decode(bytes);\r\n      }\r\n\r\n      throw new AnthropicError(\r\n        `Unexpected: received non-Uint8Array/ArrayBuffer (${\r\n          (bytes as any).constructor.name\r\n        }) in a web platform. Please report this error.`,\r\n      );\r\n    }\r\n\r\n    throw new AnthropicError(\r\n      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,\r\n    );\r\n  }\r\n\r\n  flush(): string[] {\r\n    if (!this.buffer.length && !this.trailingCR) {\r\n      return [];\r\n    }\r\n\r\n    const lines = [this.buffer.join('')];\r\n    this.buffer = [];\r\n    this.trailingCR = false;\r\n    return lines;\r\n  }\r\n}\r\n", "import { ReadableStream, type Response } from \"./_shims/index.js\";\r\nimport { AnthropicError } from \"./error.js\";\r\nimport { LineDecoder } from \"./internal/decoders/line.js\";\r\n\r\nimport { createResponseHeaders } from \"./core.js\";\r\nimport { APIError } from \"./error.js\";\r\n\r\ntype Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\r\n\r\nexport type ServerSentEvent = {\r\n  event: string | null;\r\n  data: string;\r\n  raw: string[];\r\n};\r\n\r\nexport class Stream<Item> implements AsyncIterable<Item> {\r\n  controller: AbortController;\r\n\r\n  constructor(\r\n    private iterator: () => AsyncIterator<Item>,\r\n    controller: AbortController,\r\n  ) {\r\n    this.controller = controller;\r\n  }\r\n\r\n  static fromSSEResponse<Item>(response: Response, controller: AbortController): Stream<Item> {\r\n    let consumed = false;\r\n\r\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\r\n      if (consumed) {\r\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\r\n      }\r\n      consumed = true;\r\n      let done = false;\r\n      try {\r\n        for await (const sse of _iterSSEMessages(response, controller)) {\r\n          if (sse.event === 'completion') {\r\n            try {\r\n              yield JSON.parse(sse.data);\r\n            } catch (e) {\r\n              console.error(`Could not parse message into JSON:`, sse.data);\r\n              console.error(`From chunk:`, sse.raw);\r\n              throw e;\r\n            }\r\n          }\r\n\r\n          if (\r\n            sse.event === 'message_start' ||\r\n            sse.event === 'message_delta' ||\r\n            sse.event === 'message_stop' ||\r\n            sse.event === 'content_block_start' ||\r\n            sse.event === 'content_block_delta' ||\r\n            sse.event === 'content_block_stop'\r\n          ) {\r\n            try {\r\n              yield JSON.parse(sse.data);\r\n            } catch (e) {\r\n              console.error(`Could not parse message into JSON:`, sse.data);\r\n              console.error(`From chunk:`, sse.raw);\r\n              throw e;\r\n            }\r\n          }\r\n\r\n          if (sse.event === 'ping') {\r\n            continue;\r\n          }\r\n\r\n          if (sse.event === 'error') {\r\n            throw APIError.generate(\r\n              undefined,\r\n              `SSE Error: ${sse.data}`,\r\n              sse.data,\r\n              createResponseHeaders(response.headers),\r\n            );\r\n          }\r\n        }\r\n        done = true;\r\n      } catch (e) {\r\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\r\n        if (e instanceof Error && e.name === 'AbortError') return;\r\n        throw e;\r\n      } finally {\r\n        // If the user `break`s, abort the ongoing request.\r\n        if (!done) controller.abort();\r\n      }\r\n    }\r\n\r\n    return new Stream(iterator, controller);\r\n  }\r\n\r\n  /**\r\n   * Generates a Stream from a newline-separated ReadableStream\r\n   * where each item is a JSON value.\r\n   */\r\n  static fromReadableStream<Item>(readableStream: ReadableStream, controller: AbortController): Stream<Item> {\r\n    let consumed = false;\r\n\r\n    async function* iterLines(): AsyncGenerator<string, void, unknown> {\r\n      const lineDecoder = new LineDecoder();\r\n\r\n      const iter = readableStreamAsyncIterable<Bytes>(readableStream);\r\n      for await (const chunk of iter) {\r\n        for (const line of lineDecoder.decode(chunk)) {\r\n          yield line;\r\n        }\r\n      }\r\n\r\n      for (const line of lineDecoder.flush()) {\r\n        yield line;\r\n      }\r\n    }\r\n\r\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\r\n      if (consumed) {\r\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\r\n      }\r\n      consumed = true;\r\n      let done = false;\r\n      try {\r\n        for await (const line of iterLines()) {\r\n          if (done) continue;\r\n          if (line) yield JSON.parse(line);\r\n        }\r\n        done = true;\r\n      } catch (e) {\r\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\r\n        if (e instanceof Error && e.name === 'AbortError') return;\r\n        throw e;\r\n      } finally {\r\n        // If the user `break`s, abort the ongoing request.\r\n        if (!done) controller.abort();\r\n      }\r\n    }\r\n\r\n    return new Stream(iterator, controller);\r\n  }\r\n\r\n  [Symbol.asyncIterator](): AsyncIterator<Item> {\r\n    return this.iterator();\r\n  }\r\n\r\n  /**\r\n   * Splits the stream into two streams which can be\r\n   * independently read from at different speeds.\r\n   */\r\n  tee(): [Stream<Item>, Stream<Item>] {\r\n    const left: Array<Promise<IteratorResult<Item>>> = [];\r\n    const right: Array<Promise<IteratorResult<Item>>> = [];\r\n    const iterator = this.iterator();\r\n\r\n    const teeIterator = (queue: Array<Promise<IteratorResult<Item>>>): AsyncIterator<Item> => {\r\n      return {\r\n        next: () => {\r\n          if (queue.length === 0) {\r\n            const result = iterator.next();\r\n            left.push(result);\r\n            right.push(result);\r\n          }\r\n          return queue.shift()!;\r\n        },\r\n      };\r\n    };\r\n\r\n    return [\r\n      new Stream(() => teeIterator(left), this.controller),\r\n      new Stream(() => teeIterator(right), this.controller),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Converts this stream to a newline-separated ReadableStream of\r\n   * JSON stringified values in the stream\r\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\r\n   */\r\n  toReadableStream(): ReadableStream {\r\n    const self = this;\r\n    let iter: AsyncIterator<Item>;\r\n    const encoder = new TextEncoder();\r\n\r\n    return new ReadableStream({\r\n      async start() {\r\n        iter = self[Symbol.asyncIterator]();\r\n      },\r\n      async pull(ctrl: any) {\r\n        try {\r\n          const { value, done } = await iter.next();\r\n          if (done) return ctrl.close();\r\n\r\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\r\n\r\n          ctrl.enqueue(bytes);\r\n        } catch (err) {\r\n          ctrl.error(err);\r\n        }\r\n      },\r\n      async cancel() {\r\n        await iter.return?.();\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport async function* _iterSSEMessages(\r\n  response: Response,\r\n  controller: AbortController,\r\n): AsyncGenerator<ServerSentEvent, void, unknown> {\r\n  if (!response.body) {\r\n    controller.abort();\r\n    throw new AnthropicError(`Attempted to iterate over a response with no body`);\r\n  }\r\n\r\n  const sseDecoder = new SSEDecoder();\r\n  const lineDecoder = new LineDecoder();\r\n\r\n  const iter = readableStreamAsyncIterable<Bytes>(response.body);\r\n  for await (const sseChunk of iterSSEChunks(iter)) {\r\n    for (const line of lineDecoder.decode(sseChunk)) {\r\n      const sse = sseDecoder.decode(line);\r\n      if (sse) yield sse;\r\n    }\r\n  }\r\n\r\n  for (const line of lineDecoder.flush()) {\r\n    const sse = sseDecoder.decode(line);\r\n    if (sse) yield sse;\r\n  }\r\n}\r\n\r\n/**\r\n * Given an async iterable iterator, iterates over it and yields full\r\n * SSE chunks, i.e. yields when a double new-line is encountered.\r\n */\r\nasync function* iterSSEChunks(iterator: AsyncIterableIterator<Bytes>): AsyncGenerator<Uint8Array> {\r\n  let data = new Uint8Array();\r\n\r\n  for await (const chunk of iterator) {\r\n    if (chunk == null) {\r\n      continue;\r\n    }\r\n\r\n    const binaryChunk =\r\n      chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\r\n      : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\r\n      : chunk;\r\n\r\n    let newData = new Uint8Array(data.length + binaryChunk.length);\r\n    newData.set(data);\r\n    newData.set(binaryChunk, data.length);\r\n    data = newData;\r\n\r\n    let patternIndex;\r\n    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\r\n      yield data.slice(0, patternIndex);\r\n      data = data.slice(patternIndex);\r\n    }\r\n  }\r\n\r\n  if (data.length > 0) {\r\n    yield data;\r\n  }\r\n}\r\n\r\nfunction findDoubleNewlineIndex(buffer: Uint8Array): number {\r\n  // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\r\n  // and returns the index right after the first occurrence of any pattern,\r\n  // or -1 if none of the patterns are found.\r\n  const newline = 0x0a; // \\n\r\n  const carriage = 0x0d; // \\r\r\n\r\n  for (let i = 0; i < buffer.length - 2; i++) {\r\n    if (buffer[i] === newline && buffer[i + 1] === newline) {\r\n      // \\n\\n\r\n      return i + 2;\r\n    }\r\n    if (buffer[i] === carriage && buffer[i + 1] === carriage) {\r\n      // \\r\\r\r\n      return i + 2;\r\n    }\r\n    if (\r\n      buffer[i] === carriage &&\r\n      buffer[i + 1] === newline &&\r\n      i + 3 < buffer.length &&\r\n      buffer[i + 2] === carriage &&\r\n      buffer[i + 3] === newline\r\n    ) {\r\n      // \\r\\n\\r\\n\r\n      return i + 4;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nclass SSEDecoder {\r\n  private data: string[];\r\n  private event: string | null;\r\n  private chunks: string[];\r\n\r\n  constructor() {\r\n    this.event = null;\r\n    this.data = [];\r\n    this.chunks = [];\r\n  }\r\n\r\n  decode(line: string) {\r\n    if (line.endsWith('\\r')) {\r\n      line = line.substring(0, line.length - 1);\r\n    }\r\n\r\n    if (!line) {\r\n      // empty line and we didn't previously encounter any messages\r\n      if (!this.event && !this.data.length) return null;\r\n\r\n      const sse: ServerSentEvent = {\r\n        event: this.event,\r\n        data: this.data.join('\\n'),\r\n        raw: this.chunks,\r\n      };\r\n\r\n      this.event = null;\r\n      this.data = [];\r\n      this.chunks = [];\r\n\r\n      return sse;\r\n    }\r\n\r\n    this.chunks.push(line);\r\n\r\n    if (line.startsWith(':')) {\r\n      return null;\r\n    }\r\n\r\n    let [fieldname, _, value] = partition(line, ':');\r\n\r\n    if (value.startsWith(' ')) {\r\n      value = value.substring(1);\r\n    }\r\n\r\n    if (fieldname === 'event') {\r\n      this.event = value;\r\n    } else if (fieldname === 'data') {\r\n      this.data.push(value);\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\n/** This is an internal helper function that's just used for testing */\r\nexport function _decodeChunks(chunks: string[]): string[] {\r\n  const decoder = new LineDecoder();\r\n  const lines: string[] = [];\r\n  for (const chunk of chunks) {\r\n    lines.push(...decoder.decode(chunk));\r\n  }\r\n\r\n  return lines;\r\n}\r\n\r\nfunction partition(str: string, delimiter: string): [string, string, string] {\r\n  const index = str.indexOf(delimiter);\r\n  if (index !== -1) {\r\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\r\n  }\r\n\r\n  return [str, '', ''];\r\n}\r\n\r\n/**\r\n * Most browsers don't yet have async iterable support for ReadableStream,\r\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\r\n *\r\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\r\n */\r\nexport function readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\r\n  if (stream[Symbol.asyncIterator]) return stream;\r\n\r\n  const reader = stream.getReader();\r\n  return {\r\n    async next() {\r\n      try {\r\n        const result = await reader.read();\r\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\r\n        return result;\r\n      } catch (e) {\r\n        reader.releaseLock(); // release lock when stream becomes errored\r\n        throw e;\r\n      }\r\n    },\r\n    async return() {\r\n      const cancelPromise = reader.cancel();\r\n      reader.releaseLock();\r\n      await cancelPromise;\r\n      return { done: true, value: undefined };\r\n    },\r\n    [Symbol.asyncIterator]() {\r\n      return this;\r\n    },\r\n  };\r\n}\r\n", "import { type RequestOptions } from \"./core.js\";\r\nimport {\r\n  FormData,\r\n  File,\r\n  type Blob,\r\n  type FilePropertyBag,\r\n  getMultipartRequestOptions,\r\n  type FsReadStream,\r\n  isFsReadStream,\r\n} from \"./_shims/index.js\";\r\nimport { MultipartBody } from \"./_shims/MultipartBody.js\";\r\nexport { fileFromPath } from \"./_shims/index.js\";\r\n\r\ntype BlobLikePart = string | ArrayBuffer | ArrayBufferView | BlobLike | Uint8Array | DataView;\r\nexport type BlobPart = string | ArrayBuffer | ArrayBufferView | Blob | Uint8Array | DataView;\r\n\r\n/**\r\n * Typically, this is a native \"File\" class.\r\n *\r\n * We provide the {@link toFile} utility to convert a variety of objects\r\n * into the File class.\r\n *\r\n * For convenience, you can also pass a fetch Response, or in Node,\r\n * the result of fs.createReadStream().\r\n */\r\nexport type Uploadable = FileLike | ResponseLike | FsReadStream;\r\n\r\n/**\r\n * Intended to match web.Blob, node.Blob, node-fetch.Blob, etc.\r\n */\r\nexport interface BlobLike {\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */\r\n  readonly size: number;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */\r\n  readonly type: string;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */\r\n  text(): Promise<string>;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */\r\n  slice(start?: number, end?: number): BlobLike;\r\n  // unfortunately @types/node-fetch@^2.6.4 doesn't type the arrayBuffer method\r\n}\r\n\r\n/**\r\n * Intended to match web.File, node.File, node-fetch.File, etc.\r\n */\r\nexport interface FileLike extends BlobLike {\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */\r\n  readonly lastModified: number;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */\r\n  readonly name: string;\r\n}\r\n\r\n/**\r\n * Intended to match web.Response, node.Response, node-fetch.Response, etc.\r\n */\r\nexport interface ResponseLike {\r\n  url: string;\r\n  blob(): Promise<BlobLike>;\r\n}\r\n\r\nexport const isResponseLike = (value: any): value is ResponseLike =>\r\n  value != null &&\r\n  typeof value === 'object' &&\r\n  typeof value.url === 'string' &&\r\n  typeof value.blob === 'function';\r\n\r\nexport const isFileLike = (value: any): value is FileLike =>\r\n  value != null &&\r\n  typeof value === 'object' &&\r\n  typeof value.name === 'string' &&\r\n  typeof value.lastModified === 'number' &&\r\n  isBlobLike(value);\r\n\r\n/**\r\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\r\n * adds the arrayBuffer() method type because it is available and used at runtime\r\n */\r\nexport const isBlobLike = (value: any): value is BlobLike & { arrayBuffer(): Promise<ArrayBuffer> } =>\r\n  value != null &&\r\n  typeof value === 'object' &&\r\n  typeof value.size === 'number' &&\r\n  typeof value.type === 'string' &&\r\n  typeof value.text === 'function' &&\r\n  typeof value.slice === 'function' &&\r\n  typeof value.arrayBuffer === 'function';\r\n\r\nexport const isUploadable = (value: any): value is Uploadable => {\r\n  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\r\n};\r\n\r\nexport type ToFileInput = Uploadable | Exclude<BlobLikePart, string> | AsyncIterable<BlobLikePart>;\r\n\r\n/**\r\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\r\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\r\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\r\n * @param {Object=} options additional properties\r\n * @param {string=} options.type the MIME type of the content\r\n * @param {number=} options.lastModified the last modified timestamp\r\n * @returns a {@link File} with the given properties\r\n */\r\nexport async function toFile(\r\n  value: ToFileInput | PromiseLike<ToFileInput>,\r\n  name?: string | null | undefined,\r\n  options?: FilePropertyBag | undefined,\r\n): Promise<FileLike> {\r\n  // If it's a promise, resolve it.\r\n  value = await value;\r\n\r\n  // If we've been given a `File` we don't need to do anything\r\n  if (isFileLike(value)) {\r\n    return value;\r\n  }\r\n\r\n  if (isResponseLike(value)) {\r\n    const blob = await value.blob();\r\n    name ||= new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file';\r\n\r\n    // we need to convert the `Blob` into an array buffer because the `Blob` class\r\n    // that `node-fetch` defines is incompatible with the web standard which results\r\n    // in `new File` interpreting it as a string instead of binary data.\r\n    const data = isBlobLike(blob) ? [(await blob.arrayBuffer()) as any] : [blob];\r\n\r\n    return new File(data, name, options);\r\n  }\r\n\r\n  const bits = await getBytes(value);\r\n\r\n  name ||= getName(value) ?? 'unknown_file';\r\n\r\n  if (!options?.type) {\r\n    const type = (bits[0] as any)?.type;\r\n    if (typeof type === 'string') {\r\n      options = { ...options, type };\r\n    }\r\n  }\r\n\r\n  return new File(bits, name, options);\r\n}\r\n\r\nasync function getBytes(value: ToFileInput): Promise<Array<BlobPart>> {\r\n  let parts: Array<BlobPart> = [];\r\n  if (\r\n    typeof value === 'string' ||\r\n    ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\r\n    value instanceof ArrayBuffer\r\n  ) {\r\n    parts.push(value);\r\n  } else if (isBlobLike(value)) {\r\n    parts.push(await value.arrayBuffer());\r\n  } else if (\r\n    isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\r\n  ) {\r\n    for await (const chunk of value) {\r\n      parts.push(chunk as BlobPart); // TODO, consider validating?\r\n    }\r\n  } else {\r\n    throw new Error(\r\n      `Unexpected data type: ${typeof value}; constructor: ${value?.constructor\r\n        ?.name}; props: ${propsForError(value)}`,\r\n    );\r\n  }\r\n\r\n  return parts;\r\n}\r\n\r\nfunction propsForError(value: any): string {\r\n  const props = Object.getOwnPropertyNames(value);\r\n  return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\r\n}\r\n\r\nfunction getName(value: any): string | undefined {\r\n  return (\r\n    getStringFromMaybeBuffer(value.name) ||\r\n    getStringFromMaybeBuffer(value.filename) ||\r\n    // For fs.ReadStream\r\n    getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop()\r\n  );\r\n}\r\n\r\nconst getStringFromMaybeBuffer = (x: string | Buffer | unknown): string | undefined => {\r\n  if (typeof x === 'string') return x;\r\n  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);\r\n  return undefined;\r\n};\r\n\r\nconst isAsyncIterableIterator = (value: any): value is AsyncIterableIterator<unknown> =>\r\n  value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\r\n\r\nexport const isMultipartBody = (body: any): body is MultipartBody =>\r\n  body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\r\n\r\n/**\r\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\r\n * Otherwise returns the request as is.\r\n */\r\nexport const maybeMultipartFormRequestOptions = async <T = Record<string, unknown>>(\r\n  opts: RequestOptions<T>,\r\n): Promise<RequestOptions<T | MultipartBody>> => {\r\n  if (!hasUploadableValue(opts.body)) return opts;\r\n\r\n  const form = await createForm(opts.body);\r\n  return getMultipartRequestOptions(form, opts);\r\n};\r\n\r\nexport const multipartFormRequestOptions = async <T = Record<string, unknown>>(\r\n  opts: RequestOptions<T>,\r\n): Promise<RequestOptions<T | MultipartBody>> => {\r\n  const form = await createForm(opts.body);\r\n  return getMultipartRequestOptions(form, opts);\r\n};\r\n\r\nexport const createForm = async <T = Record<string, unknown>>(body: T | undefined): Promise<FormData> => {\r\n  const form = new FormData();\r\n  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\r\n  return form;\r\n};\r\n\r\nconst hasUploadableValue = (value: unknown): boolean => {\r\n  if (isUploadable(value)) return true;\r\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\r\n  if (value && typeof value === 'object') {\r\n    for (const k in value) {\r\n      if (hasUploadableValue((value as any)[k])) return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nconst addFormValue = async (form: FormData, key: string, value: unknown): Promise<void> => {\r\n  if (value === undefined) return;\r\n  if (value == null) {\r\n    throw new TypeError(\r\n      `Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`,\r\n    );\r\n  }\r\n\r\n  // TODO: make nested formats configurable\r\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\r\n    form.append(key, String(value));\r\n  } else if (isUploadable(value)) {\r\n    const file = await toFile(value);\r\n    form.append(key, file as File);\r\n  } else if (Array.isArray(value)) {\r\n    await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\r\n  } else if (typeof value === 'object') {\r\n    await Promise.all(\r\n      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)),\r\n    );\r\n  } else {\r\n    throw new TypeError(\r\n      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`,\r\n    );\r\n  }\r\n};\r\n", "import { VERSION } from \"./version.js\";\r\nimport { Stream } from \"./streaming.js\";\r\nimport {\r\n  AnthropicError,\r\n  APIError,\r\n  APIConnectionError,\r\n  APIConnectionTimeoutError,\r\n  APIUserAbortError,\r\n} from \"./error.js\";\r\nimport {\r\n  kind as shimsKind,\r\n  type Readable,\r\n  getDefaultAgent,\r\n  type Agent,\r\n  fetch,\r\n  type RequestInfo,\r\n  type RequestInit,\r\n  type Response,\r\n  type HeadersInit,\r\n} from \"./_shims/index.js\";\r\nexport { type Response };\r\nimport { BlobLike, isBlobLike, isMultipartBody } from \"./uploads.js\";\r\nexport {\r\n  maybeMultipartFormRequestOptions,\r\n  multipartFormRequestOptions,\r\n  createForm,\r\n  type Uploadable,\r\n} from \"./uploads.js\";\r\n\r\nexport type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;\r\n\r\ntype PromiseOrValue<T> = T | Promise<T>;\r\n\r\ntype APIResponseProps = {\r\n  response: Response;\r\n  options: FinalRequestOptions;\r\n  controller: AbortController;\r\n};\r\n\r\nasync function defaultParseResponse<T>(props: APIResponseProps): Promise<WithRequestID<T>> {\r\n  const { response } = props;\r\n  if (props.options.stream) {\r\n    debug('response', response.status, response.url, response.headers, response.body);\r\n\r\n    // Note: there is an invariant here that isn't represented in the type system\r\n    // that if you set `stream: true` the response type must also be `Stream<T>`\r\n\r\n    if (props.options.__streamClass) {\r\n      return props.options.__streamClass.fromSSEResponse(response, props.controller) as any;\r\n    }\r\n\r\n    return Stream.fromSSEResponse(response, props.controller) as any;\r\n  }\r\n\r\n  // fetch refuses to read the body when the status code is 204.\r\n  if (response.status === 204) {\r\n    return null as WithRequestID<T>;\r\n  }\r\n\r\n  if (props.options.__binaryResponse) {\r\n    return response as unknown as WithRequestID<T>;\r\n  }\r\n\r\n  const contentType = response.headers.get('content-type');\r\n  const isJSON =\r\n    contentType?.includes('application/json') || contentType?.includes('application/vnd.api+json');\r\n  if (isJSON) {\r\n    const json = await response.json();\r\n\r\n    debug('response', response.status, response.url, response.headers, json);\r\n\r\n    return _addRequestID(json as T, response);\r\n  }\r\n\r\n  const text = await response.text();\r\n  debug('response', response.status, response.url, response.headers, text);\r\n\r\n  // TODO handle blob, arraybuffer, other content types, etc.\r\n  return text as unknown as WithRequestID<T>;\r\n}\r\n\r\ntype WithRequestID<T> =\r\n  T extends Array<any> | Response | AbstractPage<any> ? T\r\n  : T extends Record<string, any> ? T & { _request_id?: string | null }\r\n  : T;\r\n\r\nfunction _addRequestID<T>(value: T, response: Response): WithRequestID<T> {\r\n  if (!value || typeof value !== 'object' || Array.isArray(value)) {\r\n    return value as WithRequestID<T>;\r\n  }\r\n\r\n  return Object.defineProperty(value, '_request_id', {\r\n    value: response.headers.get('request-id'),\r\n    enumerable: false,\r\n  }) as WithRequestID<T>;\r\n}\r\n\r\n/**\r\n * A subclass of `Promise` providing additional helper methods\r\n * for interacting with the SDK.\r\n */\r\nexport class APIPromise<T> extends Promise<WithRequestID<T>> {\r\n  private parsedPromise: Promise<WithRequestID<T>> | undefined;\r\n\r\n  constructor(\r\n    private responsePromise: Promise<APIResponseProps>,\r\n    private parseResponse: (\r\n      props: APIResponseProps,\r\n    ) => PromiseOrValue<WithRequestID<T>> = defaultParseResponse,\r\n  ) {\r\n    super((resolve) => {\r\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\r\n      // parse the response body; instead .then, .catch, .finally are overridden\r\n      // to parse the response\r\n      resolve(null as any);\r\n    });\r\n  }\r\n\r\n  _thenUnwrap<U>(transform: (data: T, props: APIResponseProps) => U): APIPromise<U> {\r\n    return new APIPromise(this.responsePromise, async (props) =>\r\n      _addRequestID(transform(await this.parseResponse(props), props), props.response),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Gets the raw `Response` instance instead of parsing the response\r\n   * data.\r\n   *\r\n   * If you want to parse the response body but still get the `Response`\r\n   * instance, you can use {@link withResponse()}.\r\n   *\r\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\r\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\r\n   * or add one of these imports before your first `import â€¦ from '@anthropic-ai/sdk'`:\r\n   * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)\r\n   * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)\r\n   */\r\n  asResponse(): Promise<Response> {\r\n    return this.responsePromise.then((p) => p.response);\r\n  }\r\n\r\n  /**\r\n   * Gets the parsed response data, the raw `Response` instance and the ID of the request,\r\n   * returned vie the `request-id` header which is useful for debugging requests and resporting\r\n   * issues to Anthropic.\r\n   *\r\n   * If you just want to get the raw `Response` instance without parsing it,\r\n   * you can use {@link asResponse()}.\r\n   *\r\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\r\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\r\n   * or add one of these imports before your first `import â€¦ from '@anthropic-ai/sdk'`:\r\n   * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)\r\n   * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)\r\n   */\r\n  async withResponse(): Promise<{ data: T; response: Response; request_id: string | null | undefined }> {\r\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\r\n    return { data, response, request_id: response.headers.get('request-id') };\r\n  }\r\n\r\n  private parse(): Promise<WithRequestID<T>> {\r\n    if (!this.parsedPromise) {\r\n      this.parsedPromise = this.responsePromise.then(this.parseResponse) as any as Promise<WithRequestID<T>>;\r\n    }\r\n    return this.parsedPromise;\r\n  }\r\n\r\n  override then<TResult1 = WithRequestID<T>, TResult2 = never>(\r\n    onfulfilled?: ((value: WithRequestID<T>) => TResult1 | PromiseLike<TResult1>) | undefined | null,\r\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\r\n  ): Promise<TResult1 | TResult2> {\r\n    return this.parse().then(onfulfilled, onrejected);\r\n  }\r\n\r\n  override catch<TResult = never>(\r\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,\r\n  ): Promise<WithRequestID<T> | TResult> {\r\n    return this.parse().catch(onrejected);\r\n  }\r\n\r\n  override finally(onfinally?: (() => void) | undefined | null): Promise<WithRequestID<T>> {\r\n    return this.parse().finally(onfinally);\r\n  }\r\n}\r\n\r\nexport abstract class APIClient {\r\n  baseURL: string;\r\n  maxRetries: number;\r\n  timeout: number;\r\n  httpAgent: Agent | undefined;\r\n\r\n  private fetch: Fetch;\r\n  protected idempotencyHeader?: string;\r\n\r\n  constructor({\r\n    baseURL,\r\n    maxRetries = 2,\r\n    timeout = 600000, // 10 minutes\r\n    httpAgent,\r\n    fetch: overriddenFetch,\r\n  }: {\r\n    baseURL: string;\r\n    maxRetries?: number | undefined;\r\n    timeout: number | undefined;\r\n    httpAgent: Agent | undefined;\r\n    fetch: Fetch | undefined;\r\n  }) {\r\n    this.baseURL = baseURL;\r\n    this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\r\n    this.timeout = validatePositiveInteger('timeout', timeout);\r\n    this.httpAgent = httpAgent;\r\n\r\n    this.fetch = overriddenFetch ?? fetch;\r\n  }\r\n\r\n  protected authHeaders(opts: FinalRequestOptions): Headers {\r\n    return {};\r\n  }\r\n\r\n  /**\r\n   * Override this to add your own default headers, for example:\r\n   *\r\n   *  {\r\n   *    ...super.defaultHeaders(),\r\n   *    Authorization: 'Bearer 123',\r\n   *  }\r\n   */\r\n  protected defaultHeaders(opts: FinalRequestOptions): Headers {\r\n    return {\r\n      Accept: 'application/json',\r\n      'Content-Type': 'application/json',\r\n      'User-Agent': this.getUserAgent(),\r\n      ...getPlatformHeaders(),\r\n      ...this.authHeaders(opts),\r\n    };\r\n  }\r\n\r\n  protected abstract defaultQuery(): DefaultQuery | undefined;\r\n\r\n  /**\r\n   * Override this to add your own headers validation:\r\n   */\r\n  protected validateHeaders(headers: Headers, customHeaders: Headers) {}\r\n\r\n  protected defaultIdempotencyKey(): string {\r\n    return `stainless-node-retry-${uuid4()}`;\r\n  }\r\n\r\n  get<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('get', path, opts);\r\n  }\r\n\r\n  post<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('post', path, opts);\r\n  }\r\n\r\n  patch<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('patch', path, opts);\r\n  }\r\n\r\n  put<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('put', path, opts);\r\n  }\r\n\r\n  delete<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('delete', path, opts);\r\n  }\r\n\r\n  private methodRequest<Req, Rsp>(\r\n    method: HTTPMethod,\r\n    path: string,\r\n    opts?: PromiseOrValue<RequestOptions<Req>>,\r\n  ): APIPromise<Rsp> {\r\n    return this.request(\r\n      Promise.resolve(opts).then(async (opts) => {\r\n        const body =\r\n          opts && isBlobLike(opts?.body) ? new DataView(await opts.body.arrayBuffer())\r\n          : opts?.body instanceof DataView ? opts.body\r\n          : opts?.body instanceof ArrayBuffer ? new DataView(opts.body)\r\n          : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer)\r\n          : opts?.body;\r\n        return { method, path, ...opts, body };\r\n      }),\r\n    );\r\n  }\r\n\r\n  getAPIList<Item, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\r\n    path: string,\r\n    Page: new (...args: any[]) => PageClass,\r\n    opts?: RequestOptions<any>,\r\n  ): PagePromise<PageClass, Item> {\r\n    return this.requestAPIList(Page, { method: 'get', path, ...opts });\r\n  }\r\n\r\n  private calculateContentLength(body: unknown): string | null {\r\n    if (typeof body === 'string') {\r\n      if (typeof Buffer !== 'undefined') {\r\n        return Buffer.byteLength(body, 'utf8').toString();\r\n      }\r\n\r\n      if (typeof TextEncoder !== 'undefined') {\r\n        const encoder = new TextEncoder();\r\n        const encoded = encoder.encode(body);\r\n        return encoded.length.toString();\r\n      }\r\n    } else if (ArrayBuffer.isView(body)) {\r\n      return body.byteLength.toString();\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  buildRequest<Req>(\r\n    options: FinalRequestOptions<Req>,\r\n    { retryCount = 0 }: { retryCount?: number } = {},\r\n  ): { req: RequestInit; url: string; timeout: number } {\r\n    const { method, path, query, headers: headers = {} } = options;\r\n\r\n    const body =\r\n      ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?\r\n        options.body\r\n      : isMultipartBody(options.body) ? options.body.body\r\n      : options.body ? JSON.stringify(options.body, null, 2)\r\n      : null;\r\n    const contentLength = this.calculateContentLength(body);\r\n\r\n    const url = this.buildURL(path!, query);\r\n    if ('timeout' in options) validatePositiveInteger('timeout', options.timeout);\r\n    const timeout = options.timeout ?? this.timeout;\r\n    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\r\n    const minAgentTimeout = timeout + 1000;\r\n    if (\r\n      typeof (httpAgent as any)?.options?.timeout === 'number' &&\r\n      minAgentTimeout > ((httpAgent as any).options.timeout ?? 0)\r\n    ) {\r\n      // Allow any given request to bump our agent active socket timeout.\r\n      // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\r\n      // and without mutating agent we would need to create more of them.\r\n      // This tradeoff optimizes for performance.\r\n      (httpAgent as any).options.timeout = minAgentTimeout;\r\n    }\r\n\r\n    if (this.idempotencyHeader && method !== 'get') {\r\n      if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();\r\n      headers[this.idempotencyHeader] = options.idempotencyKey;\r\n    }\r\n\r\n    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });\r\n\r\n    const req: RequestInit = {\r\n      method,\r\n      ...(body && { body: body as any }),\r\n      headers: reqHeaders,\r\n      ...(httpAgent && { agent: httpAgent }),\r\n      // @ts-ignore node-fetch uses a custom AbortSignal type that is\r\n      // not compatible with standard web types\r\n      signal: options.signal ?? null,\r\n    };\r\n\r\n    return { req, url, timeout };\r\n  }\r\n\r\n  private buildHeaders({\r\n    options,\r\n    headers,\r\n    contentLength,\r\n    retryCount,\r\n  }: {\r\n    options: FinalRequestOptions;\r\n    headers: Record<string, string | null | undefined>;\r\n    contentLength: string | null | undefined;\r\n    retryCount: number;\r\n  }): Record<string, string> {\r\n    const reqHeaders: Record<string, string> = {};\r\n    if (contentLength) {\r\n      reqHeaders['content-length'] = contentLength;\r\n    }\r\n\r\n    const defaultHeaders = this.defaultHeaders(options);\r\n    applyHeadersMut(reqHeaders, defaultHeaders);\r\n    applyHeadersMut(reqHeaders, headers);\r\n\r\n    // let builtin fetch set the Content-Type for multipart bodies\r\n    if (isMultipartBody(options.body) && shimsKind !== 'node') {\r\n      delete reqHeaders['content-type'];\r\n    }\r\n\r\n    // Don't set the retry count header if it was already set or removed through default headers or by the\r\n    // caller. We check `defaultHeaders` and `headers`, which can contain nulls, instead of `reqHeaders` to\r\n    // account for the removal case.\r\n    if (\r\n      getHeader(defaultHeaders, 'x-stainless-retry-count') === undefined &&\r\n      getHeader(headers, 'x-stainless-retry-count') === undefined\r\n    ) {\r\n      reqHeaders['x-stainless-retry-count'] = String(retryCount);\r\n    }\r\n\r\n    this.validateHeaders(reqHeaders, headers);\r\n\r\n    return reqHeaders;\r\n  }\r\n\r\n  /**\r\n   * Used as a callback for mutating the given `FinalRequestOptions` object.\r\n   */\r\n  protected async prepareOptions(options: FinalRequestOptions): Promise<void> {}\r\n\r\n  /**\r\n   * Used as a callback for mutating the given `RequestInit` object.\r\n   *\r\n   * This is useful for cases where you want to add certain headers based off of\r\n   * the request properties, e.g. `method` or `url`.\r\n   */\r\n  protected async prepareRequest(\r\n    request: RequestInit,\r\n    { url, options }: { url: string; options: FinalRequestOptions },\r\n  ): Promise<void> {}\r\n\r\n  protected parseHeaders(headers: HeadersInit | null | undefined): Record<string, string> {\r\n    return (\r\n      !headers ? {}\r\n      : Symbol.iterator in headers ?\r\n        Object.fromEntries(Array.from(headers as Iterable<string[]>).map((header) => [...header]))\r\n      : { ...headers }\r\n    );\r\n  }\r\n\r\n  protected makeStatusError(\r\n    status: number | undefined,\r\n    error: Object | undefined,\r\n    message: string | undefined,\r\n    headers: Headers | undefined,\r\n  ): APIError {\r\n    return APIError.generate(status, error, message, headers);\r\n  }\r\n\r\n  request<Req, Rsp>(\r\n    options: PromiseOrValue<FinalRequestOptions<Req>>,\r\n    remainingRetries: number | null = null,\r\n  ): APIPromise<Rsp> {\r\n    return new APIPromise(this.makeRequest(options, remainingRetries));\r\n  }\r\n\r\n  private async makeRequest<Req>(\r\n    optionsInput: PromiseOrValue<FinalRequestOptions<Req>>,\r\n    retriesRemaining: number | null,\r\n  ): Promise<APIResponseProps> {\r\n    const options = await optionsInput;\r\n    const maxRetries = options.maxRetries ?? this.maxRetries;\r\n    if (retriesRemaining == null) {\r\n      retriesRemaining = maxRetries;\r\n    }\r\n\r\n    await this.prepareOptions(options);\r\n\r\n    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });\r\n\r\n    await this.prepareRequest(req, { url, options });\r\n\r\n    debug('request', url, options, req.headers);\r\n\r\n    if (options.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n\r\n    const controller = new AbortController();\r\n    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\r\n\r\n    if (response instanceof Error) {\r\n      if (options.signal?.aborted) {\r\n        throw new APIUserAbortError();\r\n      }\r\n      if (retriesRemaining) {\r\n        return this.retryRequest(options, retriesRemaining);\r\n      }\r\n      if (response.name === 'AbortError') {\r\n        throw new APIConnectionTimeoutError();\r\n      }\r\n      throw new APIConnectionError({ cause: response });\r\n    }\r\n\r\n    const responseHeaders = createResponseHeaders(response.headers);\r\n\r\n    if (!response.ok) {\r\n      if (retriesRemaining && this.shouldRetry(response)) {\r\n        const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\r\n        debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\r\n        return this.retryRequest(options, retriesRemaining, responseHeaders);\r\n      }\r\n\r\n      const errText = await response.text().catch((e) => castToError(e).message);\r\n      const errJSON = safeJSON(errText);\r\n      const errMessage = errJSON ? undefined : errText;\r\n      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\r\n\r\n      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\r\n\r\n      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\r\n      throw err;\r\n    }\r\n\r\n    return { response, options, controller };\r\n  }\r\n\r\n  requestAPIList<Item = unknown, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\r\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\r\n    options: FinalRequestOptions,\r\n  ): PagePromise<PageClass, Item> {\r\n    const request = this.makeRequest(options, null);\r\n    return new PagePromise<PageClass, Item>(this, request, Page);\r\n  }\r\n\r\n  buildURL<Req>(path: string, query: Req | null | undefined): string {\r\n    const url =\r\n      isAbsoluteURL(path) ?\r\n        new URL(path)\r\n      : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\r\n\r\n    const defaultQuery = this.defaultQuery();\r\n    if (!isEmptyObj(defaultQuery)) {\r\n      query = { ...defaultQuery, ...query } as Req;\r\n    }\r\n\r\n    if (typeof query === 'object' && query && !Array.isArray(query)) {\r\n      url.search = this.stringifyQuery(query as Record<string, unknown>);\r\n    }\r\n\r\n    return url.toString();\r\n  }\r\n\r\n  protected stringifyQuery(query: Record<string, unknown>): string {\r\n    return Object.entries(query)\r\n      .filter(([_, value]) => typeof value !== 'undefined')\r\n      .map(([key, value]) => {\r\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\r\n          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\r\n        }\r\n        if (value === null) {\r\n          return `${encodeURIComponent(key)}=`;\r\n        }\r\n        throw new AnthropicError(\r\n          `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`,\r\n        );\r\n      })\r\n      .join('&');\r\n  }\r\n\r\n  async fetchWithTimeout(\r\n    url: RequestInfo,\r\n    init: RequestInit | undefined,\r\n    ms: number,\r\n    controller: AbortController,\r\n  ): Promise<Response> {\r\n    const { signal, ...options } = init || {};\r\n    if (signal) signal.addEventListener('abort', () => controller.abort());\r\n\r\n    const timeout = setTimeout(() => controller.abort(), ms);\r\n\r\n    return (\r\n      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\r\n      this.fetch.call(undefined, url, { signal: controller.signal as any, ...options }).finally(() => {\r\n        clearTimeout(timeout);\r\n      })\r\n    );\r\n  }\r\n\r\n  private shouldRetry(response: Response): boolean {\r\n    // Note this is not a standard header.\r\n    const shouldRetryHeader = response.headers.get('x-should-retry');\r\n\r\n    // If the server explicitly says whether or not to retry, obey.\r\n    if (shouldRetryHeader === 'true') return true;\r\n    if (shouldRetryHeader === 'false') return false;\r\n\r\n    // Retry on request timeouts.\r\n    if (response.status === 408) return true;\r\n\r\n    // Retry on lock timeouts.\r\n    if (response.status === 409) return true;\r\n\r\n    // Retry on rate limits.\r\n    if (response.status === 429) return true;\r\n\r\n    // Retry internal errors.\r\n    if (response.status >= 500) return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  private async retryRequest(\r\n    options: FinalRequestOptions,\r\n    retriesRemaining: number,\r\n    responseHeaders?: Headers | undefined,\r\n  ): Promise<APIResponseProps> {\r\n    let timeoutMillis: number | undefined;\r\n\r\n    // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\r\n    const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];\r\n    if (retryAfterMillisHeader) {\r\n      const timeoutMs = parseFloat(retryAfterMillisHeader);\r\n      if (!Number.isNaN(timeoutMs)) {\r\n        timeoutMillis = timeoutMs;\r\n      }\r\n    }\r\n\r\n    // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\r\n    const retryAfterHeader = responseHeaders?.['retry-after'];\r\n    if (retryAfterHeader && !timeoutMillis) {\r\n      const timeoutSeconds = parseFloat(retryAfterHeader);\r\n      if (!Number.isNaN(timeoutSeconds)) {\r\n        timeoutMillis = timeoutSeconds * 1000;\r\n      } else {\r\n        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\r\n      }\r\n    }\r\n\r\n    // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\r\n    // just do what it says, but otherwise calculate a default\r\n    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\r\n      const maxRetries = options.maxRetries ?? this.maxRetries;\r\n      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\r\n    }\r\n    await sleep(timeoutMillis);\r\n\r\n    return this.makeRequest(options, retriesRemaining - 1);\r\n  }\r\n\r\n  private calculateDefaultRetryTimeoutMillis(retriesRemaining: number, maxRetries: number): number {\r\n    const initialRetryDelay = 0.5;\r\n    const maxRetryDelay = 8.0;\r\n\r\n    const numRetries = maxRetries - retriesRemaining;\r\n\r\n    // Apply exponential backoff, but not more than the max.\r\n    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\r\n\r\n    // Apply some jitter, take up to at most 25 percent of the retry time.\r\n    const jitter = 1 - Math.random() * 0.25;\r\n\r\n    return sleepSeconds * jitter * 1000;\r\n  }\r\n\r\n  private getUserAgent(): string {\r\n    return `${this.constructor.name}/JS ${VERSION}`;\r\n  }\r\n}\r\n\r\nexport type PageInfo = { url: URL } | { params: Record<string, unknown> | null };\r\n\r\nexport abstract class AbstractPage<Item> implements AsyncIterable<Item> {\r\n  #client: APIClient;\r\n  protected options: FinalRequestOptions;\r\n\r\n  protected response: Response;\r\n  protected body: unknown;\r\n\r\n  constructor(client: APIClient, response: Response, body: unknown, options: FinalRequestOptions) {\r\n    this.#client = client;\r\n    this.options = options;\r\n    this.response = response;\r\n    this.body = body;\r\n  }\r\n\r\n  /**\r\n   * @deprecated Use nextPageInfo instead\r\n   */\r\n  abstract nextPageParams(): Partial<Record<string, unknown>> | null;\r\n  abstract nextPageInfo(): PageInfo | null;\r\n\r\n  abstract getPaginatedItems(): Item[];\r\n\r\n  hasNextPage(): boolean {\r\n    const items = this.getPaginatedItems();\r\n    if (!items.length) return false;\r\n    return this.nextPageInfo() != null;\r\n  }\r\n\r\n  async getNextPage(): Promise<this> {\r\n    const nextInfo = this.nextPageInfo();\r\n    if (!nextInfo) {\r\n      throw new AnthropicError(\r\n        'No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.',\r\n      );\r\n    }\r\n    const nextOptions = { ...this.options };\r\n    if ('params' in nextInfo && typeof nextOptions.query === 'object') {\r\n      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\r\n    } else if ('url' in nextInfo) {\r\n      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\r\n      for (const [key, value] of params) {\r\n        nextInfo.url.searchParams.set(key, value as any);\r\n      }\r\n      nextOptions.query = undefined;\r\n      nextOptions.path = nextInfo.url.toString();\r\n    }\r\n    return await this.#client.requestAPIList(this.constructor as any, nextOptions);\r\n  }\r\n\r\n  async *iterPages(): AsyncGenerator<this> {\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    let page: this = this;\r\n    yield page;\r\n    while (page.hasNextPage()) {\r\n      page = await page.getNextPage();\r\n      yield page;\r\n    }\r\n  }\r\n\r\n  async *[Symbol.asyncIterator](): AsyncGenerator<Item> {\r\n    for await (const page of this.iterPages()) {\r\n      for (const item of page.getPaginatedItems()) {\r\n        yield item;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\r\n *\r\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\r\n *\r\n *    for await (const item of client.items.list()) {\r\n *      console.log(item)\r\n *    }\r\n */\r\nexport class PagePromise<\r\n    PageClass extends AbstractPage<Item>,\r\n    Item = ReturnType<PageClass['getPaginatedItems']>[number],\r\n  >\r\n  extends APIPromise<PageClass>\r\n  implements AsyncIterable<Item>\r\n{\r\n  constructor(\r\n    client: APIClient,\r\n    request: Promise<APIResponseProps>,\r\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\r\n  ) {\r\n    super(\r\n      request,\r\n      async (props) =>\r\n        new Page(\r\n          client,\r\n          props.response,\r\n          await defaultParseResponse(props),\r\n          props.options,\r\n        ) as WithRequestID<PageClass>,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Allow auto-paginating iteration on an unawaited list call, eg:\r\n   *\r\n   *    for await (const item of client.items.list()) {\r\n   *      console.log(item)\r\n   *    }\r\n   */\r\n  async *[Symbol.asyncIterator](): AsyncGenerator<Item> {\r\n    const page = await this;\r\n    for await (const item of page) {\r\n      yield item;\r\n    }\r\n  }\r\n}\r\n\r\nexport const createResponseHeaders = (\r\n  headers: Awaited<ReturnType<Fetch>>['headers'],\r\n): Record<string, string> => {\r\n  return new Proxy(\r\n    Object.fromEntries(\r\n      // @ts-ignore\r\n      headers.entries(),\r\n    ),\r\n    {\r\n      get(target, name) {\r\n        const key = name.toString();\r\n        return target[key.toLowerCase()] || target[key];\r\n      },\r\n    },\r\n  );\r\n};\r\n\r\ntype HTTPMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';\r\n\r\nexport type RequestClient = { fetch: Fetch };\r\nexport type Headers = Record<string, string | null | undefined>;\r\nexport type DefaultQuery = Record<string, string | undefined>;\r\nexport type KeysEnum<T> = { [P in keyof Required<T>]: true };\r\n\r\nexport type RequestOptions<\r\n  Req = unknown | Record<string, unknown> | Readable | BlobLike | ArrayBufferView | ArrayBuffer,\r\n> = {\r\n  method?: HTTPMethod;\r\n  path?: string;\r\n  query?: Req | undefined;\r\n  body?: Req | null | undefined;\r\n  headers?: Headers | undefined;\r\n\r\n  maxRetries?: number;\r\n  stream?: boolean | undefined;\r\n  timeout?: number;\r\n  httpAgent?: Agent;\r\n  signal?: AbortSignal | undefined | null;\r\n  idempotencyKey?: string;\r\n\r\n  __binaryRequest?: boolean | undefined;\r\n  __binaryResponse?: boolean | undefined;\r\n  __streamClass?: typeof Stream;\r\n};\r\n\r\n// This is required so that we can determine if a given object matches the RequestOptions\r\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\r\n// compiler such that any missing / extraneous keys will cause an error.\r\nconst requestOptionsKeys: KeysEnum<RequestOptions> = {\r\n  method: true,\r\n  path: true,\r\n  query: true,\r\n  body: true,\r\n  headers: true,\r\n\r\n  maxRetries: true,\r\n  stream: true,\r\n  timeout: true,\r\n  httpAgent: true,\r\n  signal: true,\r\n  idempotencyKey: true,\r\n\r\n  __binaryRequest: true,\r\n  __binaryResponse: true,\r\n  __streamClass: true,\r\n};\r\n\r\nexport const isRequestOptions = (obj: unknown): obj is RequestOptions => {\r\n  return (\r\n    typeof obj === 'object' &&\r\n    obj !== null &&\r\n    !isEmptyObj(obj) &&\r\n    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))\r\n  );\r\n};\r\n\r\nexport type FinalRequestOptions<Req = unknown | Record<string, unknown> | Readable | DataView> =\r\n  RequestOptions<Req> & {\r\n    method: HTTPMethod;\r\n    path: string;\r\n  };\r\n\r\ndeclare const Deno: any;\r\ndeclare const EdgeRuntime: any;\r\ntype Arch = 'x32' | 'x64' | 'arm' | 'arm64' | `other:${string}` | 'unknown';\r\ntype PlatformName =\r\n  | 'MacOS'\r\n  | 'Linux'\r\n  | 'Windows'\r\n  | 'FreeBSD'\r\n  | 'OpenBSD'\r\n  | 'iOS'\r\n  | 'Android'\r\n  | `Other:${string}`\r\n  | 'Unknown';\r\ntype Browser = 'ie' | 'edge' | 'chrome' | 'firefox' | 'safari';\r\ntype PlatformProperties = {\r\n  'X-Stainless-Lang': 'js';\r\n  'X-Stainless-Package-Version': string;\r\n  'X-Stainless-OS': PlatformName;\r\n  'X-Stainless-Arch': Arch;\r\n  'X-Stainless-Runtime': 'node' | 'deno' | 'edge' | `browser:${Browser}` | 'unknown';\r\n  'X-Stainless-Runtime-Version': string;\r\n};\r\nconst getPlatformProperties = (): PlatformProperties => {\r\n  if (typeof Deno !== 'undefined' && Deno.build != null) {\r\n    return {\r\n      'X-Stainless-Lang': 'js',\r\n      'X-Stainless-Package-Version': VERSION,\r\n      'X-Stainless-OS': normalizePlatform(Deno.build.os),\r\n      'X-Stainless-Arch': normalizeArch(Deno.build.arch),\r\n      'X-Stainless-Runtime': 'deno',\r\n      'X-Stainless-Runtime-Version':\r\n        typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\r\n    };\r\n  }\r\n  if (typeof EdgeRuntime !== 'undefined') {\r\n    return {\r\n      'X-Stainless-Lang': 'js',\r\n      'X-Stainless-Package-Version': VERSION,\r\n      'X-Stainless-OS': 'Unknown',\r\n      'X-Stainless-Arch': `other:${EdgeRuntime}`,\r\n      'X-Stainless-Runtime': 'edge',\r\n      'X-Stainless-Runtime-Version': process.version,\r\n    };\r\n  }\r\n  // Check if Node.js\r\n  if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\r\n    return {\r\n      'X-Stainless-Lang': 'js',\r\n      'X-Stainless-Package-Version': VERSION,\r\n      'X-Stainless-OS': normalizePlatform(process.platform),\r\n      'X-Stainless-Arch': normalizeArch(process.arch),\r\n      'X-Stainless-Runtime': 'node',\r\n      'X-Stainless-Runtime-Version': process.version,\r\n    };\r\n  }\r\n\r\n  const browserInfo = getBrowserInfo();\r\n  if (browserInfo) {\r\n    return {\r\n      'X-Stainless-Lang': 'js',\r\n      'X-Stainless-Package-Version': VERSION,\r\n      'X-Stainless-OS': 'Unknown',\r\n      'X-Stainless-Arch': 'unknown',\r\n      'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\r\n      'X-Stainless-Runtime-Version': browserInfo.version,\r\n    };\r\n  }\r\n\r\n  // TODO add support for Cloudflare workers, etc.\r\n  return {\r\n    'X-Stainless-Lang': 'js',\r\n    'X-Stainless-Package-Version': VERSION,\r\n    'X-Stainless-OS': 'Unknown',\r\n    'X-Stainless-Arch': 'unknown',\r\n    'X-Stainless-Runtime': 'unknown',\r\n    'X-Stainless-Runtime-Version': 'unknown',\r\n  };\r\n};\r\n\r\ntype BrowserInfo = {\r\n  browser: Browser;\r\n  version: string;\r\n};\r\n\r\ndeclare const navigator: { userAgent: string } | undefined;\r\n\r\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\r\nfunction getBrowserInfo(): BrowserInfo | null {\r\n  if (typeof navigator === 'undefined' || !navigator) {\r\n    return null;\r\n  }\r\n\r\n  // NOTE: The order matters here!\r\n  const browserPatterns = [\r\n    { key: 'edge' as const, pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'ie' as const, pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'ie' as const, pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'chrome' as const, pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'firefox' as const, pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'safari' as const, pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\r\n  ];\r\n\r\n  // Find the FIRST matching browser\r\n  for (const { key, pattern } of browserPatterns) {\r\n    const match = pattern.exec(navigator.userAgent);\r\n    if (match) {\r\n      const major = match[1] || 0;\r\n      const minor = match[2] || 0;\r\n      const patch = match[3] || 0;\r\n\r\n      return { browser: key, version: `${major}.${minor}.${patch}` };\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nconst normalizeArch = (arch: string): Arch => {\r\n  // Node docs:\r\n  // - https://nodejs.org/api/process.html#processarch\r\n  // Deno docs:\r\n  // - https://doc.deno.land/deno/stable/~/Deno.build\r\n  if (arch === 'x32') return 'x32';\r\n  if (arch === 'x86_64' || arch === 'x64') return 'x64';\r\n  if (arch === 'arm') return 'arm';\r\n  if (arch === 'aarch64' || arch === 'arm64') return 'arm64';\r\n  if (arch) return `other:${arch}`;\r\n  return 'unknown';\r\n};\r\n\r\nconst normalizePlatform = (platform: string): PlatformName => {\r\n  // Node platforms:\r\n  // - https://nodejs.org/api/process.html#processplatform\r\n  // Deno platforms:\r\n  // - https://doc.deno.land/deno/stable/~/Deno.build\r\n  // - https://github.com/denoland/deno/issues/14799\r\n\r\n  platform = platform.toLowerCase();\r\n\r\n  // NOTE: this iOS check is untested and may not work\r\n  // Node does not work natively on IOS, there is a fork at\r\n  // https://github.com/nodejs-mobile/nodejs-mobile\r\n  // however it is unknown at the time of writing how to detect if it is running\r\n  if (platform.includes('ios')) return 'iOS';\r\n  if (platform === 'android') return 'Android';\r\n  if (platform === 'darwin') return 'MacOS';\r\n  if (platform === 'win32') return 'Windows';\r\n  if (platform === 'freebsd') return 'FreeBSD';\r\n  if (platform === 'openbsd') return 'OpenBSD';\r\n  if (platform === 'linux') return 'Linux';\r\n  if (platform) return `Other:${platform}`;\r\n  return 'Unknown';\r\n};\r\n\r\nlet _platformHeaders: PlatformProperties;\r\nconst getPlatformHeaders = () => {\r\n  return (_platformHeaders ??= getPlatformProperties());\r\n};\r\n\r\nexport const safeJSON = (text: string) => {\r\n  try {\r\n    return JSON.parse(text);\r\n  } catch (err) {\r\n    return undefined;\r\n  }\r\n};\r\n\r\n// https://url.spec.whatwg.org/#url-scheme-string\r\nconst startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;\r\nconst isAbsoluteURL = (url: string): boolean => {\r\n  return startsWithSchemeRegexp.test(url);\r\n};\r\n\r\nexport const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\r\n\r\nconst validatePositiveInteger = (name: string, n: unknown): number => {\r\n  if (typeof n !== 'number' || !Number.isInteger(n)) {\r\n    throw new AnthropicError(`${name} must be an integer`);\r\n  }\r\n  if (n < 0) {\r\n    throw new AnthropicError(`${name} must be a positive integer`);\r\n  }\r\n  return n;\r\n};\r\n\r\nexport const castToError = (err: any): Error => {\r\n  if (err instanceof Error) return err;\r\n  if (typeof err === 'object' && err !== null) {\r\n    try {\r\n      return new Error(JSON.stringify(err));\r\n    } catch {}\r\n  }\r\n  return new Error(String(err));\r\n};\r\n\r\nexport const ensurePresent = <T>(value: T | null | undefined): T => {\r\n  if (value == null) throw new AnthropicError(`Expected a value to be given but received ${value} instead.`);\r\n  return value;\r\n};\r\n\r\n/**\r\n * Read an environment variable.\r\n *\r\n * Trims beginning and trailing whitespace.\r\n *\r\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\r\n */\r\nexport const readEnv = (env: string): string | undefined => {\r\n  if (typeof process !== 'undefined') {\r\n    return process.env?.[env]?.trim() ?? undefined;\r\n  }\r\n  if (typeof Deno !== 'undefined') {\r\n    return Deno.env?.get?.(env)?.trim();\r\n  }\r\n  return undefined;\r\n};\r\n\r\nexport const coerceInteger = (value: unknown): number => {\r\n  if (typeof value === 'number') return Math.round(value);\r\n  if (typeof value === 'string') return parseInt(value, 10);\r\n\r\n  throw new AnthropicError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\r\n};\r\n\r\nexport const coerceFloat = (value: unknown): number => {\r\n  if (typeof value === 'number') return value;\r\n  if (typeof value === 'string') return parseFloat(value);\r\n\r\n  throw new AnthropicError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\r\n};\r\n\r\nexport const coerceBoolean = (value: unknown): boolean => {\r\n  if (typeof value === 'boolean') return value;\r\n  if (typeof value === 'string') return value === 'true';\r\n  return Boolean(value);\r\n};\r\n\r\nexport const maybeCoerceInteger = (value: unknown): number | undefined => {\r\n  if (value === undefined) {\r\n    return undefined;\r\n  }\r\n  return coerceInteger(value);\r\n};\r\n\r\nexport const maybeCoerceFloat = (value: unknown): number | undefined => {\r\n  if (value === undefined) {\r\n    return undefined;\r\n  }\r\n  return coerceFloat(value);\r\n};\r\n\r\nexport const maybeCoerceBoolean = (value: unknown): boolean | undefined => {\r\n  if (value === undefined) {\r\n    return undefined;\r\n  }\r\n  return coerceBoolean(value);\r\n};\r\n\r\n// https://stackoverflow.com/a/34491287\r\nexport function isEmptyObj(obj: Object | null | undefined): boolean {\r\n  if (!obj) return true;\r\n  for (const _k in obj) return false;\r\n  return true;\r\n}\r\n\r\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\r\nexport function hasOwn(obj: Object, key: string): boolean {\r\n  return Object.prototype.hasOwnProperty.call(obj, key);\r\n}\r\n\r\n/**\r\n * Copies headers from \"newHeaders\" onto \"targetHeaders\",\r\n * using lower-case for all properties,\r\n * ignoring any keys with undefined values,\r\n * and deleting any keys with null values.\r\n */\r\nfunction applyHeadersMut(targetHeaders: Headers, newHeaders: Headers): void {\r\n  for (const k in newHeaders) {\r\n    if (!hasOwn(newHeaders, k)) continue;\r\n    const lowerKey = k.toLowerCase();\r\n    if (!lowerKey) continue;\r\n\r\n    const val = newHeaders[k];\r\n\r\n    if (val === null) {\r\n      delete targetHeaders[lowerKey];\r\n    } else if (val !== undefined) {\r\n      targetHeaders[lowerKey] = val;\r\n    }\r\n  }\r\n}\r\n\r\nexport function debug(action: string, ...args: any[]) {\r\n  if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {\r\n    console.log(`Anthropic:DEBUG:${action}`, ...args);\r\n  }\r\n}\r\n\r\n/**\r\n * https://stackoverflow.com/a/2117523\r\n */\r\nconst uuid4 = () => {\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n    const r = (Math.random() * 16) | 0;\r\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n    return v.toString(16);\r\n  });\r\n};\r\n\r\nexport const isRunningInBrowser = () => {\r\n  return (\r\n    // @ts-ignore\r\n    typeof window !== 'undefined' &&\r\n    // @ts-ignore\r\n    typeof window.document !== 'undefined' &&\r\n    // @ts-ignore\r\n    typeof navigator !== 'undefined'\r\n  );\r\n};\r\n\r\nexport interface HeadersProtocol {\r\n  get: (header: string) => string | null | undefined;\r\n}\r\nexport type HeadersLike = Record<string, string | string[] | undefined> | HeadersProtocol;\r\n\r\nexport const isHeadersProtocol = (headers: any): headers is HeadersProtocol => {\r\n  return typeof headers?.get === 'function';\r\n};\r\n\r\nexport const getRequiredHeader = (headers: HeadersLike | Headers, header: string): string => {\r\n  const foundHeader = getHeader(headers, header);\r\n  if (foundHeader === undefined) {\r\n    throw new Error(`Could not find ${header} header`);\r\n  }\r\n  return foundHeader;\r\n};\r\n\r\nexport const getHeader = (headers: HeadersLike | Headers, header: string): string | undefined => {\r\n  const lowerCasedHeader = header.toLowerCase();\r\n  if (isHeadersProtocol(headers)) {\r\n    // to deal with the case where the header looks like Stainless-Event-Id\r\n    const intercapsHeader =\r\n      header[0]?.toUpperCase() +\r\n      header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\r\n    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\r\n      const value = headers.get(key);\r\n      if (value) {\r\n        return value;\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const [key, value] of Object.entries(headers)) {\r\n    if (key.toLowerCase() === lowerCasedHeader) {\r\n      if (Array.isArray(value)) {\r\n        if (value.length <= 1) return value[0];\r\n        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\r\n        return value[0];\r\n      }\r\n      return value;\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n};\r\n\r\n/**\r\n * Encodes a string to Base64 format.\r\n */\r\nexport const toBase64 = (str: string | null | undefined): string => {\r\n  if (!str) return '';\r\n  if (typeof Buffer !== 'undefined') {\r\n    return Buffer.from(str).toString('base64');\r\n  }\r\n\r\n  if (typeof btoa !== 'undefined') {\r\n    return btoa(str);\r\n  }\r\n\r\n  throw new AnthropicError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\r\n};\r\n\r\nexport function isObj(obj: unknown): obj is Record<string, unknown> {\r\n  return obj != null && typeof obj === 'object' && !Array.isArray(obj);\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { AbstractPage, Response, APIClient, FinalRequestOptions, PageInfo } from \"./core.js\";\r\n\r\nexport interface PageResponse<Item> {\r\n  data: Array<Item>;\r\n\r\n  has_more: boolean;\r\n\r\n  first_id: string | null;\r\n\r\n  last_id: string | null;\r\n}\r\n\r\nexport interface PageParams {\r\n  /**\r\n   * Number of items per page.\r\n   */\r\n  limit?: number;\r\n\r\n  before_id?: string;\r\n\r\n  after_id?: string;\r\n}\r\n\r\nexport class Page<Item> extends AbstractPage<Item> implements PageResponse<Item> {\r\n  data: Array<Item>;\r\n\r\n  has_more: boolean;\r\n\r\n  first_id: string | null;\r\n\r\n  last_id: string | null;\r\n\r\n  constructor(client: APIClient, response: Response, body: PageResponse<Item>, options: FinalRequestOptions) {\r\n    super(client, response, body, options);\r\n\r\n    this.data = body.data || [];\r\n    this.has_more = body.has_more || false;\r\n    this.first_id = body.first_id || null;\r\n    this.last_id = body.last_id || null;\r\n  }\r\n\r\n  getPaginatedItems(): Item[] {\r\n    return this.data ?? [];\r\n  }\r\n\r\n  // @deprecated Please use `nextPageInfo()` instead\r\n  nextPageParams(): Partial<PageParams> | null {\r\n    const info = this.nextPageInfo();\r\n    if (!info) return null;\r\n    if ('params' in info) return info.params;\r\n    const params = Object.fromEntries(info.url.searchParams);\r\n    if (!Object.keys(params).length) return null;\r\n    return params;\r\n  }\r\n\r\n  nextPageInfo(): PageInfo | null {\r\n    if ((this.options.query as Record<string, unknown>)?.['before_id']) {\r\n      // in reverse\r\n      const firstId = this.first_id;\r\n      if (!firstId) {\r\n        return null;\r\n      }\r\n\r\n      return {\r\n        params: {\r\n          before_id: firstId,\r\n        },\r\n      };\r\n    }\r\n\r\n    const cursor = this.last_id;\r\n    if (!cursor) {\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      params: {\r\n        after_id: cursor,\r\n      },\r\n    };\r\n  }\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport * as Core from \"./core.js\";\r\n\r\nexport class APIResource {\r\n  protected _client: Core.APIClient;\r\n\r\n  constructor(client: Core.APIClient) {\r\n    this._client = client;\r\n  }\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from \"../../resource.js\";\r\nimport { isRequestOptions } from \"../../core.js\";\r\nimport * as Core from \"../../core.js\";\r\nimport { Page, type PageParams } from \"../../pagination.js\";\r\n\r\nexport class Models extends APIResource {\r\n  /**\r\n   * Get a specific model.\r\n   *\r\n   * The Models API response can be used to determine information about a specific\r\n   * model or resolve a model alias to a model ID.\r\n   */\r\n  retrieve(modelId: string, options?: Core.RequestOptions): Core.APIPromise<BetaModelInfo> {\r\n    return this._client.get(`/v1/models/${modelId}?beta=true`, options);\r\n  }\r\n\r\n  /**\r\n   * List available models.\r\n   *\r\n   * The Models API response can be used to determine which models are available for\r\n   * use in the API. More recently released models are listed first.\r\n   */\r\n  list(\r\n    query?: ModelListParams,\r\n    options?: Core.RequestOptions,\r\n  ): Core.PagePromise<BetaModelInfosPage, BetaModelInfo>;\r\n  list(options?: Core.RequestOptions): Core.PagePromise<BetaModelInfosPage, BetaModelInfo>;\r\n  list(\r\n    query: ModelListParams | Core.RequestOptions = {},\r\n    options?: Core.RequestOptions,\r\n  ): Core.PagePromise<BetaModelInfosPage, BetaModelInfo> {\r\n    if (isRequestOptions(query)) {\r\n      return this.list({}, query);\r\n    }\r\n    return this._client.getAPIList('/v1/models?beta=true', BetaModelInfosPage, { query, ...options });\r\n  }\r\n}\r\n\r\nexport class BetaModelInfosPage extends Page<BetaModelInfo> {}\r\n\r\nexport interface BetaModelInfo {\r\n  /**\r\n   * Unique model identifier.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * RFC 3339 datetime string representing the time at which the model was released.\r\n   * May be set to an epoch value if the release date is unknown.\r\n   */\r\n  created_at: string;\r\n\r\n  /**\r\n   * A human-readable name for the model.\r\n   */\r\n  display_name: string;\r\n\r\n  /**\r\n   * Object type.\r\n   *\r\n   * For Models, this is always `\"model\"`.\r\n   */\r\n  type: 'model';\r\n}\r\n\r\nexport interface ModelListParams extends PageParams {}\r\n\r\nModels.BetaModelInfosPage = BetaModelInfosPage;\r\n\r\nexport declare namespace Models {\r\n  export {\r\n    type BetaModelInfo as BetaModelInfo,\r\n    BetaModelInfosPage as BetaModelInfosPage,\r\n    type ModelListParams as ModelListParams,\r\n  };\r\n}\r\n", "import { AnthropicError } from \"../../error.js\";\r\nimport { readableStreamAsyncIterable } from \"../../streaming.js\";\r\nimport { type Response } from \"../../_shims/index.js\";\r\nimport { LineDecoder, type Bytes } from \"./line.js\";\r\n\r\nexport class JSONLDecoder<T> {\r\n  controller: AbortController;\r\n\r\n  constructor(\r\n    private iterator: AsyncIterableIterator<Bytes>,\r\n    controller: AbortController,\r\n  ) {\r\n    this.controller = controller;\r\n  }\r\n\r\n  private async *decoder(): AsyncIterator<T, any, undefined> {\r\n    const lineDecoder = new LineDecoder();\r\n    for await (const chunk of this.iterator) {\r\n      for (const line of lineDecoder.decode(chunk)) {\r\n        yield JSON.parse(line);\r\n      }\r\n    }\r\n\r\n    for (const line of lineDecoder.flush()) {\r\n      yield JSON.parse(line);\r\n    }\r\n  }\r\n\r\n  [Symbol.asyncIterator](): AsyncIterator<T> {\r\n    return this.decoder();\r\n  }\r\n\r\n  static fromResponse<T>(response: Response, controller: AbortController): JSONLDecoder<T> {\r\n    if (!response.body) {\r\n      controller.abort();\r\n      throw new AnthropicError(`Attempted to iterate over a response with no body`);\r\n    }\r\n\r\n    return new JSONLDecoder(readableStreamAsyncIterable<Bytes>(response.body), controller);\r\n  }\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from \"../../../resource.js\";\r\nimport { isRequestOptions } from \"../../../core.js\";\r\nimport * as Core from \"../../../core.js\";\r\nimport * as BetaAPI from \"../beta.js\";\r\nimport * as BetaMessagesAPI from \"./messages.js\";\r\nimport { Page, type PageParams } from \"../../../pagination.js\";\r\nimport { JSONLDecoder } from \"../../../internal/decoders/jsonl.js\";\r\nimport { AnthropicError } from \"../../../error.js\";\r\n\r\nexport class Batches extends APIResource {\r\n  /**\r\n   * Send a batch of Message creation requests.\r\n   *\r\n   * The Message Batches API can be used to process multiple Messages API requests at\r\n   * once. Once a Message Batch is created, it begins processing immediately. Batches\r\n   * can take up to 24 hours to complete.\r\n   */\r\n  create(params: BatchCreateParams, options?: Core.RequestOptions): Core.APIPromise<BetaMessageBatch> {\r\n    const { betas, ...body } = params;\r\n    return this._client.post('/v1/messages/batches?beta=true', {\r\n      body,\r\n      ...options,\r\n      headers: {\r\n        'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString(),\r\n        ...options?.headers,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This endpoint is idempotent and can be used to poll for Message Batch\r\n   * completion. To access the results of a Message Batch, make a request to the\r\n   * `results_url` field in the response.\r\n   */\r\n  retrieve(\r\n    messageBatchId: string,\r\n    params?: BatchRetrieveParams,\r\n    options?: Core.RequestOptions,\r\n  ): Core.APIPromise<BetaMessageBatch>;\r\n  retrieve(messageBatchId: string, options?: Core.RequestOptions): Core.APIPromise<BetaMessageBatch>;\r\n  retrieve(\r\n    messageBatchId: string,\r\n    params: BatchRetrieveParams | Core.RequestOptions = {},\r\n    options?: Core.RequestOptions,\r\n  ): Core.APIPromise<BetaMessageBatch> {\r\n    if (isRequestOptions(params)) {\r\n      return this.retrieve(messageBatchId, {}, params);\r\n    }\r\n    const { betas } = params;\r\n    return this._client.get(`/v1/messages/batches/${messageBatchId}?beta=true`, {\r\n      ...options,\r\n      headers: {\r\n        'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString(),\r\n        ...options?.headers,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * List all Message Batches within a Workspace. Most recently created batches are\r\n   * returned first.\r\n   */\r\n  list(\r\n    params?: BatchListParams,\r\n    options?: Core.RequestOptions,\r\n  ): Core.PagePromise<BetaMessageBatchesPage, BetaMessageBatch>;\r\n  list(options?: Core.RequestOptions): Core.PagePromise<BetaMessageBatchesPage, BetaMessageBatch>;\r\n  list(\r\n    params: BatchListParams | Core.RequestOptions = {},\r\n    options?: Core.RequestOptions,\r\n  ): Core.PagePromise<BetaMessageBatchesPage, BetaMessageBatch> {\r\n    if (isRequestOptions(params)) {\r\n      return this.list({}, params);\r\n    }\r\n    const { betas, ...query } = params;\r\n    return this._client.getAPIList('/v1/messages/batches?beta=true', BetaMessageBatchesPage, {\r\n      query,\r\n      ...options,\r\n      headers: {\r\n        'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString(),\r\n        ...options?.headers,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Batches may be canceled any time before processing ends. Once cancellation is\r\n   * initiated, the batch enters a `canceling` state, at which time the system may\r\n   * complete any in-progress, non-interruptible requests before finalizing\r\n   * cancellation.\r\n   *\r\n   * The number of canceled requests is specified in `request_counts`. To determine\r\n   * which requests were canceled, check the individual results within the batch.\r\n   * Note that cancellation may not result in any canceled requests if they were\r\n   * non-interruptible.\r\n   */\r\n  cancel(\r\n    messageBatchId: string,\r\n    params?: BatchCancelParams,\r\n    options?: Core.RequestOptions,\r\n  ): Core.APIPromise<BetaMessageBatch>;\r\n  cancel(messageBatchId: string, options?: Core.RequestOptions): Core.APIPromise<BetaMessageBatch>;\r\n  cancel(\r\n    messageBatchId: string,\r\n    params: BatchCancelParams | Core.RequestOptions = {},\r\n    options?: Core.RequestOptions,\r\n  ): Core.APIPromise<BetaMessageBatch> {\r\n    if (isRequestOptions(params)) {\r\n      return this.cancel(messageBatchId, {}, params);\r\n    }\r\n    const { betas } = params;\r\n    return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel?beta=true`, {\r\n      ...options,\r\n      headers: {\r\n        'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString(),\r\n        ...options?.headers,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Streams the results of a Message Batch as a `.jsonl` file.\r\n   *\r\n   * Each line in the file is a JSON object containing the result of a single request\r\n   * in the Message Batch. Results are not guaranteed to be in the same order as\r\n   * requests. Use the `custom_id` field to match results to requests.\r\n   */\r\n  async results(\r\n    messageBatchId: string,\r\n    params?: BatchResultsParams,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<JSONLDecoder<BetaMessageBatchIndividualResponse>>;\r\n  async results(\r\n    messageBatchId: string,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<JSONLDecoder<BetaMessageBatchIndividualResponse>>;\r\n  async results(\r\n    messageBatchId: string,\r\n    params: BatchResultsParams | Core.RequestOptions = {},\r\n    options?: Core.RequestOptions,\r\n  ): Promise<JSONLDecoder<BetaMessageBatchIndividualResponse>> {\r\n    if (isRequestOptions(params)) {\r\n      return this.results(messageBatchId, {}, params);\r\n    }\r\n\r\n    const batch = await this.retrieve(messageBatchId);\r\n    if (!batch.results_url) {\r\n      throw new AnthropicError(\r\n        `No batch \\`results_url\\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`,\r\n      );\r\n    }\r\n\r\n    const { betas } = params;\r\n    return this._client\r\n      .get(batch.results_url, {\r\n        ...options,\r\n        headers: {\r\n          'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString(),\r\n          ...options?.headers,\r\n        },\r\n        __binaryResponse: true,\r\n      })\r\n      ._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));\r\n  }\r\n}\r\n\r\nexport class BetaMessageBatchesPage extends Page<BetaMessageBatch> {}\r\n\r\nexport interface BetaMessageBatch {\r\n  /**\r\n   * Unique object identifier.\r\n   *\r\n   * The format and length of IDs may change over time.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * RFC 3339 datetime string representing the time at which the Message Batch was\r\n   * archived and its results became unavailable.\r\n   */\r\n  archived_at: string | null;\r\n\r\n  /**\r\n   * RFC 3339 datetime string representing the time at which cancellation was\r\n   * initiated for the Message Batch. Specified only if cancellation was initiated.\r\n   */\r\n  cancel_initiated_at: string | null;\r\n\r\n  /**\r\n   * RFC 3339 datetime string representing the time at which the Message Batch was\r\n   * created.\r\n   */\r\n  created_at: string;\r\n\r\n  /**\r\n   * RFC 3339 datetime string representing the time at which processing for the\r\n   * Message Batch ended. Specified only once processing ends.\r\n   *\r\n   * Processing ends when every request in a Message Batch has either succeeded,\r\n   * errored, canceled, or expired.\r\n   */\r\n  ended_at: string | null;\r\n\r\n  /**\r\n   * RFC 3339 datetime string representing the time at which the Message Batch will\r\n   * expire and end processing, which is 24 hours after creation.\r\n   */\r\n  expires_at: string;\r\n\r\n  /**\r\n   * Processing status of the Message Batch.\r\n   */\r\n  processing_status: 'in_progress' | 'canceling' | 'ended';\r\n\r\n  /**\r\n   * Tallies requests within the Message Batch, categorized by their status.\r\n   *\r\n   * Requests start as `processing` and move to one of the other statuses only once\r\n   * processing of the entire batch ends. The sum of all values always matches the\r\n   * total number of requests in the batch.\r\n   */\r\n  request_counts: BetaMessageBatchRequestCounts;\r\n\r\n  /**\r\n   * URL to a `.jsonl` file containing the results of the Message Batch requests.\r\n   * Specified only once processing ends.\r\n   *\r\n   * Results in the file are not guaranteed to be in the same order as requests. Use\r\n   * the `custom_id` field to match results to requests.\r\n   */\r\n  results_url: string | null;\r\n\r\n  /**\r\n   * Object type.\r\n   *\r\n   * For Message Batches, this is always `\"message_batch\"`.\r\n   */\r\n  type: 'message_batch';\r\n}\r\n\r\nexport interface BetaMessageBatchCanceledResult {\r\n  type: 'canceled';\r\n}\r\n\r\nexport interface BetaMessageBatchErroredResult {\r\n  error: BetaAPI.BetaErrorResponse;\r\n\r\n  type: 'errored';\r\n}\r\n\r\nexport interface BetaMessageBatchExpiredResult {\r\n  type: 'expired';\r\n}\r\n\r\nexport interface BetaMessageBatchIndividualResponse {\r\n  /**\r\n   * Developer-provided ID created for each request in a Message Batch. Useful for\r\n   * matching results to requests, as results may be given out of request order.\r\n   *\r\n   * Must be unique for each request within the Message Batch.\r\n   */\r\n  custom_id: string;\r\n\r\n  /**\r\n   * Processing result for this request.\r\n   *\r\n   * Contains a Message output if processing was successful, an error response if\r\n   * processing failed, or the reason why processing was not attempted, such as\r\n   * cancellation or expiration.\r\n   */\r\n  result: BetaMessageBatchResult;\r\n}\r\n\r\nexport interface BetaMessageBatchRequestCounts {\r\n  /**\r\n   * Number of requests in the Message Batch that have been canceled.\r\n   *\r\n   * This is zero until processing of the entire Message Batch has ended.\r\n   */\r\n  canceled: number;\r\n\r\n  /**\r\n   * Number of requests in the Message Batch that encountered an error.\r\n   *\r\n   * This is zero until processing of the entire Message Batch has ended.\r\n   */\r\n  errored: number;\r\n\r\n  /**\r\n   * Number of requests in the Message Batch that have expired.\r\n   *\r\n   * This is zero until processing of the entire Message Batch has ended.\r\n   */\r\n  expired: number;\r\n\r\n  /**\r\n   * Number of requests in the Message Batch that are processing.\r\n   */\r\n  processing: number;\r\n\r\n  /**\r\n   * Number of requests in the Message Batch that have completed successfully.\r\n   *\r\n   * This is zero until processing of the entire Message Batch has ended.\r\n   */\r\n  succeeded: number;\r\n}\r\n\r\n/**\r\n * Processing result for this request.\r\n *\r\n * Contains a Message output if processing was successful, an error response if\r\n * processing failed, or the reason why processing was not attempted, such as\r\n * cancellation or expiration.\r\n */\r\nexport type BetaMessageBatchResult =\r\n  | BetaMessageBatchSucceededResult\r\n  | BetaMessageBatchErroredResult\r\n  | BetaMessageBatchCanceledResult\r\n  | BetaMessageBatchExpiredResult;\r\n\r\nexport interface BetaMessageBatchSucceededResult {\r\n  message: BetaMessagesAPI.BetaMessage;\r\n\r\n  type: 'succeeded';\r\n}\r\n\r\nexport interface BatchCreateParams {\r\n  /**\r\n   * Body param: List of requests for prompt completion. Each is an individual\r\n   * request to create a Message.\r\n   */\r\n  requests: Array<BatchCreateParams.Request>;\r\n\r\n  /**\r\n   * Header param: Optional header to specify the beta version(s) you want to use.\r\n   */\r\n  betas?: Array<BetaAPI.AnthropicBeta>;\r\n}\r\n\r\nexport namespace BatchCreateParams {\r\n  export interface Request {\r\n    /**\r\n     * Developer-provided ID created for each request in a Message Batch. Useful for\r\n     * matching results to requests, as results may be given out of request order.\r\n     *\r\n     * Must be unique for each request within the Message Batch.\r\n     */\r\n    custom_id: string;\r\n\r\n    /**\r\n     * Messages API creation parameters for the individual request.\r\n     *\r\n     * See the [Messages API reference](/en/api/messages) for full documentation on\r\n     * available parameters.\r\n     */\r\n    params: Omit<BetaMessagesAPI.MessageCreateParamsNonStreaming, 'betas'>;\r\n  }\r\n}\r\n\r\nexport interface BatchRetrieveParams {\r\n  /**\r\n   * Optional header to specify the beta version(s) you want to use.\r\n   */\r\n  betas?: Array<BetaAPI.AnthropicBeta>;\r\n}\r\n\r\nexport interface BatchListParams extends PageParams {\r\n  /**\r\n   * Header param: Optional header to specify the beta version(s) you want to use.\r\n   */\r\n  betas?: Array<BetaAPI.AnthropicBeta>;\r\n}\r\n\r\nexport interface BatchCancelParams {\r\n  /**\r\n   * Optional header to specify the beta version(s) you want to use.\r\n   */\r\n  betas?: Array<BetaAPI.AnthropicBeta>;\r\n}\r\n\r\nexport interface BatchResultsParams {\r\n  /**\r\n   * Optional header to specify the beta version(s) you want to use.\r\n   */\r\n  betas?: Array<BetaAPI.AnthropicBeta>;\r\n}\r\n\r\nBatches.BetaMessageBatchesPage = BetaMessageBatchesPage;\r\n\r\nexport declare namespace Batches {\r\n  export {\r\n    type BetaMessageBatch as BetaMessageBatch,\r\n    type BetaMessageBatchCanceledResult as BetaMessageBatchCanceledResult,\r\n    type BetaMessageBatchErroredResult as BetaMessageBatchErroredResult,\r\n    type BetaMessageBatchExpiredResult as BetaMessageBatchExpiredResult,\r\n    type BetaMessageBatchIndividualResponse as BetaMessageBatchIndividualResponse,\r\n    type BetaMessageBatchRequestCounts as BetaMessageBatchRequestCounts,\r\n    type BetaMessageBatchResult as BetaMessageBatchResult,\r\n    type BetaMessageBatchSucceededResult as BetaMessageBatchSucceededResult,\r\n    BetaMessageBatchesPage as BetaMessageBatchesPage,\r\n    type BatchCreateParams as BatchCreateParams,\r\n    type BatchRetrieveParams as BatchRetrieveParams,\r\n    type BatchListParams as BatchListParams,\r\n    type BatchCancelParams as BatchCancelParams,\r\n    type BatchResultsParams as BatchResultsParams,\r\n  };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from \"../../../resource.js\";\r\nimport { APIPromise } from \"../../../core.js\";\r\nimport * as Core from \"../../../core.js\";\r\nimport * as MessagesMessagesAPI from \"./messages.js\";\r\nimport * as BetaAPI from \"../beta.js\";\r\nimport * as MessagesAPI from \"../../messages/messages.js\";\r\nimport * as BatchesAPI from \"./batches.js\";\r\nimport {\r\n  BatchCancelParams,\r\n  BatchCreateParams,\r\n  BatchListParams,\r\n  BatchResultsParams,\r\n  BatchRetrieveParams,\r\n  Batches,\r\n  BetaMessageBatch,\r\n  BetaMessageBatchCanceledResult,\r\n  BetaMessageBatchErroredResult,\r\n  BetaMessageBatchExpiredResult,\r\n  BetaMessageBatchIndividualResponse,\r\n  BetaMessageBatchRequestCounts,\r\n  BetaMessageBatchResult,\r\n  BetaMessageBatchSucceededResult,\r\n  BetaMessageBatchesPage,\r\n} from \"./batches.js\";\r\nimport { Stream } from \"../../../streaming.js\";\r\n\r\nexport class Messages extends APIResource {\r\n  batches: BatchesAPI.Batches = new BatchesAPI.Batches(this._client);\r\n\r\n  /**\r\n   * Send a structured list of input messages with text and/or image content, and the\r\n   * model will generate the next message in the conversation.\r\n   *\r\n   * The Messages API can be used for either single queries or stateless multi-turn\r\n   * conversations.\r\n   */\r\n  create(params: MessageCreateParamsNonStreaming, options?: Core.RequestOptions): APIPromise<BetaMessage>;\r\n  create(\r\n    params: MessageCreateParamsStreaming,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Stream<BetaRawMessageStreamEvent>>;\r\n  create(\r\n    params: MessageCreateParamsBase,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Stream<BetaRawMessageStreamEvent> | BetaMessage>;\r\n  create(\r\n    params: MessageCreateParams,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<BetaMessage> | APIPromise<Stream<BetaRawMessageStreamEvent>> {\r\n    const { betas, ...body } = params;\r\n    return this._client.post('/v1/messages?beta=true', {\r\n      body,\r\n      timeout: (this._client as any)._options.timeout ?? 600000,\r\n      ...options,\r\n      headers: {\r\n        ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined),\r\n        ...options?.headers,\r\n      },\r\n      stream: params.stream ?? false,\r\n    }) as APIPromise<BetaMessage> | APIPromise<Stream<BetaRawMessageStreamEvent>>;\r\n  }\r\n\r\n  /**\r\n   * Count the number of tokens in a Message.\r\n   *\r\n   * The Token Count API can be used to count the number of tokens in a Message,\r\n   * including tools, images, and documents, without creating it.\r\n   */\r\n  countTokens(\r\n    params: MessageCountTokensParams,\r\n    options?: Core.RequestOptions,\r\n  ): Core.APIPromise<BetaMessageTokensCount> {\r\n    const { betas, ...body } = params;\r\n    return this._client.post('/v1/messages/count_tokens?beta=true', {\r\n      body,\r\n      ...options,\r\n      headers: {\r\n        'anthropic-beta': [...(betas ?? []), 'token-counting-2024-11-01'].toString(),\r\n        ...options?.headers,\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport interface BetaBase64PDFBlock {\r\n  source: BetaBase64PDFSource;\r\n\r\n  type: 'document';\r\n\r\n  cache_control?: BetaCacheControlEphemeral | null;\r\n}\r\n\r\nexport interface BetaBase64PDFSource {\r\n  data: string;\r\n\r\n  media_type: 'application/pdf';\r\n\r\n  type: 'base64';\r\n}\r\n\r\nexport interface BetaCacheControlEphemeral {\r\n  type: 'ephemeral';\r\n}\r\n\r\nexport type BetaContentBlock = BetaTextBlock | BetaToolUseBlock;\r\n\r\nexport type BetaContentBlockParam =\r\n  | BetaTextBlockParam\r\n  | BetaImageBlockParam\r\n  | BetaToolUseBlockParam\r\n  | BetaToolResultBlockParam\r\n  | BetaBase64PDFBlock;\r\n\r\nexport interface BetaImageBlockParam {\r\n  source: BetaImageBlockParam.Source;\r\n\r\n  type: 'image';\r\n\r\n  cache_control?: BetaCacheControlEphemeral | null;\r\n}\r\n\r\nexport namespace BetaImageBlockParam {\r\n  export interface Source {\r\n    data: string;\r\n\r\n    media_type: 'image/jpeg' | 'image/png' | 'image/gif' | 'image/webp';\r\n\r\n    type: 'base64';\r\n  }\r\n}\r\n\r\nexport interface BetaInputJSONDelta {\r\n  partial_json: string;\r\n\r\n  type: 'input_json_delta';\r\n}\r\n\r\nexport interface BetaMessage {\r\n  /**\r\n   * Unique object identifier.\r\n   *\r\n   * The format and length of IDs may change over time.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * Content generated by the model.\r\n   *\r\n   * This is an array of content blocks, each of which has a `type` that determines\r\n   * its shape.\r\n   *\r\n   * Example:\r\n   *\r\n   * ```json\r\n   * [{ \"type\": \"text\", \"text\": \"Hi, I'm Claude.\" }]\r\n   * ```\r\n   *\r\n   * If the request input `messages` ended with an `assistant` turn, then the\r\n   * response `content` will continue directly from that last turn. You can use this\r\n   * to constrain the model's output.\r\n   *\r\n   * For example, if the input `messages` were:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"role\": \"user\",\r\n   *     \"content\": \"What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun\"\r\n   *   },\r\n   *   { \"role\": \"assistant\", \"content\": \"The best answer is (\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Then the response `content` might be:\r\n   *\r\n   * ```json\r\n   * [{ \"type\": \"text\", \"text\": \"B)\" }]\r\n   * ```\r\n   */\r\n  content: Array<BetaContentBlock>;\r\n\r\n  /**\r\n   * The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: MessagesAPI.Model;\r\n\r\n  /**\r\n   * Conversational role of the generated message.\r\n   *\r\n   * This will always be `\"assistant\"`.\r\n   */\r\n  role: 'assistant';\r\n\r\n  /**\r\n   * The reason that we stopped.\r\n   *\r\n   * This may be one the following values:\r\n   *\r\n   * - `\"end_turn\"`: the model reached a natural stopping point\r\n   * - `\"max_tokens\"`: we exceeded the requested `max_tokens` or the model's maximum\r\n   * - `\"stop_sequence\"`: one of your provided custom `stop_sequences` was generated\r\n   * - `\"tool_use\"`: the model invoked one or more tools\r\n   *\r\n   * In non-streaming mode this value is always non-null. In streaming mode, it is\r\n   * null in the `message_start` event and non-null otherwise.\r\n   */\r\n  stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use' | null;\r\n\r\n  /**\r\n   * Which custom stop sequence was generated, if any.\r\n   *\r\n   * This value will be a non-null string if one of your custom stop sequences was\r\n   * generated.\r\n   */\r\n  stop_sequence: string | null;\r\n\r\n  /**\r\n   * Object type.\r\n   *\r\n   * For Messages, this is always `\"message\"`.\r\n   */\r\n  type: 'message';\r\n\r\n  /**\r\n   * Billing and rate-limit usage.\r\n   *\r\n   * Anthropic's API bills and rate-limits by token counts, as tokens represent the\r\n   * underlying cost to our systems.\r\n   *\r\n   * Under the hood, the API transforms requests into a format suitable for the\r\n   * model. The model's output then goes through a parsing stage before becoming an\r\n   * API response. As a result, the token counts in `usage` will not match one-to-one\r\n   * with the exact visible content of an API request or response.\r\n   *\r\n   * For example, `output_tokens` will be non-zero, even for an empty string response\r\n   * from Claude.\r\n   */\r\n  usage: BetaUsage;\r\n}\r\n\r\nexport interface BetaMessageDeltaUsage {\r\n  /**\r\n   * The cumulative number of output tokens which were used.\r\n   */\r\n  output_tokens: number;\r\n}\r\n\r\nexport interface BetaMessageParam {\r\n  content: string | Array<BetaContentBlockParam>;\r\n\r\n  role: 'user' | 'assistant';\r\n}\r\n\r\nexport interface BetaMessageTokensCount {\r\n  /**\r\n   * The total number of tokens across the provided list of messages, system prompt,\r\n   * and tools.\r\n   */\r\n  input_tokens: number;\r\n}\r\n\r\nexport interface BetaMetadata {\r\n  /**\r\n   * An external identifier for the user who is associated with the request.\r\n   *\r\n   * This should be a uuid, hash value, or other opaque identifier. Anthropic may use\r\n   * this id to help detect abuse. Do not include any identifying information such as\r\n   * name, email address, or phone number.\r\n   */\r\n  user_id?: string | null;\r\n}\r\n\r\nexport interface BetaRawContentBlockDeltaEvent {\r\n  delta: BetaTextDelta | BetaInputJSONDelta;\r\n\r\n  index: number;\r\n\r\n  type: 'content_block_delta';\r\n}\r\n\r\nexport interface BetaRawContentBlockStartEvent {\r\n  content_block: BetaTextBlock | BetaToolUseBlock;\r\n\r\n  index: number;\r\n\r\n  type: 'content_block_start';\r\n}\r\n\r\nexport interface BetaRawContentBlockStopEvent {\r\n  index: number;\r\n\r\n  type: 'content_block_stop';\r\n}\r\n\r\nexport interface BetaRawMessageDeltaEvent {\r\n  delta: BetaRawMessageDeltaEvent.Delta;\r\n\r\n  type: 'message_delta';\r\n\r\n  /**\r\n   * Billing and rate-limit usage.\r\n   *\r\n   * Anthropic's API bills and rate-limits by token counts, as tokens represent the\r\n   * underlying cost to our systems.\r\n   *\r\n   * Under the hood, the API transforms requests into a format suitable for the\r\n   * model. The model's output then goes through a parsing stage before becoming an\r\n   * API response. As a result, the token counts in `usage` will not match one-to-one\r\n   * with the exact visible content of an API request or response.\r\n   *\r\n   * For example, `output_tokens` will be non-zero, even for an empty string response\r\n   * from Claude.\r\n   */\r\n  usage: BetaMessageDeltaUsage;\r\n}\r\n\r\nexport namespace BetaRawMessageDeltaEvent {\r\n  export interface Delta {\r\n    stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use' | null;\r\n\r\n    stop_sequence: string | null;\r\n  }\r\n}\r\n\r\nexport interface BetaRawMessageStartEvent {\r\n  message: BetaMessage;\r\n\r\n  type: 'message_start';\r\n}\r\n\r\nexport interface BetaRawMessageStopEvent {\r\n  type: 'message_stop';\r\n}\r\n\r\nexport type BetaRawMessageStreamEvent =\r\n  | BetaRawMessageStartEvent\r\n  | BetaRawMessageDeltaEvent\r\n  | BetaRawMessageStopEvent\r\n  | BetaRawContentBlockStartEvent\r\n  | BetaRawContentBlockDeltaEvent\r\n  | BetaRawContentBlockStopEvent;\r\n\r\nexport interface BetaTextBlock {\r\n  text: string;\r\n\r\n  type: 'text';\r\n}\r\n\r\nexport interface BetaTextBlockParam {\r\n  text: string;\r\n\r\n  type: 'text';\r\n\r\n  cache_control?: BetaCacheControlEphemeral | null;\r\n}\r\n\r\nexport interface BetaTextDelta {\r\n  text: string;\r\n\r\n  type: 'text_delta';\r\n}\r\n\r\nexport interface BetaTool {\r\n  /**\r\n   * [JSON schema](https://json-schema.org/) for this tool's input.\r\n   *\r\n   * This defines the shape of the `input` that your tool accepts and that the model\r\n   * will produce.\r\n   */\r\n  input_schema: BetaTool.InputSchema;\r\n\r\n  /**\r\n   * Name of the tool.\r\n   *\r\n   * This is how the tool will be called by the model and in tool_use blocks.\r\n   */\r\n  name: string;\r\n\r\n  cache_control?: BetaCacheControlEphemeral | null;\r\n\r\n  /**\r\n   * Description of what this tool does.\r\n   *\r\n   * Tool descriptions should be as detailed as possible. The more information that\r\n   * the model has about what the tool is and how to use it, the better it will\r\n   * perform. You can use natural language descriptions to reinforce important\r\n   * aspects of the tool input JSON schema.\r\n   */\r\n  description?: string;\r\n\r\n  type?: 'custom' | null;\r\n}\r\n\r\nexport namespace BetaTool {\r\n  /**\r\n   * [JSON schema](https://json-schema.org/) for this tool's input.\r\n   *\r\n   * This defines the shape of the `input` that your tool accepts and that the model\r\n   * will produce.\r\n   */\r\n  export interface InputSchema {\r\n    type: 'object';\r\n\r\n    properties?: unknown | null;\r\n    [k: string]: unknown;\r\n  }\r\n}\r\n\r\nexport interface BetaToolBash20241022 {\r\n  /**\r\n   * Name of the tool.\r\n   *\r\n   * This is how the tool will be called by the model and in tool_use blocks.\r\n   */\r\n  name: 'bash';\r\n\r\n  type: 'bash_20241022';\r\n\r\n  cache_control?: BetaCacheControlEphemeral | null;\r\n}\r\n\r\n/**\r\n * How the model should use the provided tools. The model can use a specific tool,\r\n * any available tool, or decide by itself.\r\n */\r\nexport type BetaToolChoice = BetaToolChoiceAuto | BetaToolChoiceAny | BetaToolChoiceTool;\r\n\r\n/**\r\n * The model will use any available tools.\r\n */\r\nexport interface BetaToolChoiceAny {\r\n  type: 'any';\r\n\r\n  /**\r\n   * Whether to disable parallel tool use.\r\n   *\r\n   * Defaults to `false`. If set to `true`, the model will output exactly one tool\r\n   * use.\r\n   */\r\n  disable_parallel_tool_use?: boolean;\r\n}\r\n\r\n/**\r\n * The model will automatically decide whether to use tools.\r\n */\r\nexport interface BetaToolChoiceAuto {\r\n  type: 'auto';\r\n\r\n  /**\r\n   * Whether to disable parallel tool use.\r\n   *\r\n   * Defaults to `false`. If set to `true`, the model will output at most one tool\r\n   * use.\r\n   */\r\n  disable_parallel_tool_use?: boolean;\r\n}\r\n\r\n/**\r\n * The model will use the specified tool with `tool_choice.name`.\r\n */\r\nexport interface BetaToolChoiceTool {\r\n  /**\r\n   * The name of the tool to use.\r\n   */\r\n  name: string;\r\n\r\n  type: 'tool';\r\n\r\n  /**\r\n   * Whether to disable parallel tool use.\r\n   *\r\n   * Defaults to `false`. If set to `true`, the model will output exactly one tool\r\n   * use.\r\n   */\r\n  disable_parallel_tool_use?: boolean;\r\n}\r\n\r\nexport interface BetaToolComputerUse20241022 {\r\n  /**\r\n   * The height of the display in pixels.\r\n   */\r\n  display_height_px: number;\r\n\r\n  /**\r\n   * The width of the display in pixels.\r\n   */\r\n  display_width_px: number;\r\n\r\n  /**\r\n   * Name of the tool.\r\n   *\r\n   * This is how the tool will be called by the model and in tool_use blocks.\r\n   */\r\n  name: 'computer';\r\n\r\n  type: 'computer_20241022';\r\n\r\n  cache_control?: BetaCacheControlEphemeral | null;\r\n\r\n  /**\r\n   * The X11 display number (e.g. 0, 1) for the display.\r\n   */\r\n  display_number?: number | null;\r\n}\r\n\r\nexport interface BetaToolResultBlockParam {\r\n  tool_use_id: string;\r\n\r\n  type: 'tool_result';\r\n\r\n  cache_control?: BetaCacheControlEphemeral | null;\r\n\r\n  content?: string | Array<BetaTextBlockParam | BetaImageBlockParam>;\r\n\r\n  is_error?: boolean;\r\n}\r\n\r\nexport interface BetaToolTextEditor20241022 {\r\n  /**\r\n   * Name of the tool.\r\n   *\r\n   * This is how the tool will be called by the model and in tool_use blocks.\r\n   */\r\n  name: 'str_replace_editor';\r\n\r\n  type: 'text_editor_20241022';\r\n\r\n  cache_control?: BetaCacheControlEphemeral | null;\r\n}\r\n\r\nexport type BetaToolUnion =\r\n  | BetaTool\r\n  | BetaToolComputerUse20241022\r\n  | BetaToolBash20241022\r\n  | BetaToolTextEditor20241022;\r\n\r\nexport interface BetaToolUseBlock {\r\n  id: string;\r\n\r\n  input: unknown;\r\n\r\n  name: string;\r\n\r\n  type: 'tool_use';\r\n}\r\n\r\nexport interface BetaToolUseBlockParam {\r\n  id: string;\r\n\r\n  input: unknown;\r\n\r\n  name: string;\r\n\r\n  type: 'tool_use';\r\n\r\n  cache_control?: BetaCacheControlEphemeral | null;\r\n}\r\n\r\nexport interface BetaUsage {\r\n  /**\r\n   * The number of input tokens used to create the cache entry.\r\n   */\r\n  cache_creation_input_tokens: number | null;\r\n\r\n  /**\r\n   * The number of input tokens read from the cache.\r\n   */\r\n  cache_read_input_tokens: number | null;\r\n\r\n  /**\r\n   * The number of input tokens which were used.\r\n   */\r\n  input_tokens: number;\r\n\r\n  /**\r\n   * The number of output tokens which were used.\r\n   */\r\n  output_tokens: number;\r\n}\r\n\r\nexport type MessageCreateParams = MessageCreateParamsNonStreaming | MessageCreateParamsStreaming;\r\n\r\nexport interface MessageCreateParamsBase {\r\n  /**\r\n   * Body param: The maximum number of tokens to generate before stopping.\r\n   *\r\n   * Note that our models may stop _before_ reaching this maximum. This parameter\r\n   * only specifies the absolute maximum number of tokens to generate.\r\n   *\r\n   * Different models have different maximum values for this parameter. See\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for details.\r\n   */\r\n  max_tokens: number;\r\n\r\n  /**\r\n   * Body param: Input messages.\r\n   *\r\n   * Our models are trained to operate on alternating `user` and `assistant`\r\n   * conversational turns. When creating a new `Message`, you specify the prior\r\n   * conversational turns with the `messages` parameter, and the model then generates\r\n   * the next `Message` in the conversation. Consecutive `user` or `assistant` turns\r\n   * in your request will be combined into a single turn.\r\n   *\r\n   * Each input message must be an object with a `role` and `content`. You can\r\n   * specify a single `user`-role message, or you can include multiple `user` and\r\n   * `assistant` messages.\r\n   *\r\n   * If the final message uses the `assistant` role, the response content will\r\n   * continue immediately from the content in that message. This can be used to\r\n   * constrain part of the model's response.\r\n   *\r\n   * Example with a single `user` message:\r\n   *\r\n   * ```json\r\n   * [{ \"role\": \"user\", \"content\": \"Hello, Claude\" }]\r\n   * ```\r\n   *\r\n   * Example with multiple conversational turns:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   { \"role\": \"user\", \"content\": \"Hello there.\" },\r\n   *   { \"role\": \"assistant\", \"content\": \"Hi, I'm Claude. How can I help you?\" },\r\n   *   { \"role\": \"user\", \"content\": \"Can you explain LLMs in plain English?\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Example with a partially-filled response from Claude:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"role\": \"user\",\r\n   *     \"content\": \"What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun\"\r\n   *   },\r\n   *   { \"role\": \"assistant\", \"content\": \"The best answer is (\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Each input message `content` may be either a single `string` or an array of\r\n   * content blocks, where each block has a specific `type`. Using a `string` for\r\n   * `content` is shorthand for an array of one content block of type `\"text\"`. The\r\n   * following input messages are equivalent:\r\n   *\r\n   * ```json\r\n   * { \"role\": \"user\", \"content\": \"Hello, Claude\" }\r\n   * ```\r\n   *\r\n   * ```json\r\n   * { \"role\": \"user\", \"content\": [{ \"type\": \"text\", \"text\": \"Hello, Claude\" }] }\r\n   * ```\r\n   *\r\n   * Starting with Claude 3 models, you can also send image content blocks:\r\n   *\r\n   * ```json\r\n   * {\r\n   *   \"role\": \"user\",\r\n   *   \"content\": [\r\n   *     {\r\n   *       \"type\": \"image\",\r\n   *       \"source\": {\r\n   *         \"type\": \"base64\",\r\n   *         \"media_type\": \"image/jpeg\",\r\n   *         \"data\": \"/9j/4AAQSkZJRg...\"\r\n   *       }\r\n   *     },\r\n   *     { \"type\": \"text\", \"text\": \"What is in this image?\" }\r\n   *   ]\r\n   * }\r\n   * ```\r\n   *\r\n   * We currently support the `base64` source type for images, and the `image/jpeg`,\r\n   * `image/png`, `image/gif`, and `image/webp` media types.\r\n   *\r\n   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for\r\n   * more input examples.\r\n   *\r\n   * Note that if you want to include a\r\n   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use\r\n   * the top-level `system` parameter â€” there is no `\"system\"` role for input\r\n   * messages in the Messages API.\r\n   */\r\n  messages: Array<BetaMessageParam>;\r\n\r\n  /**\r\n   * Body param: The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: MessagesAPI.Model;\r\n\r\n  /**\r\n   * Body param: An object describing metadata about the request.\r\n   */\r\n  metadata?: BetaMetadata;\r\n\r\n  /**\r\n   * Body param: Custom text sequences that will cause the model to stop generating.\r\n   *\r\n   * Our models will normally stop when they have naturally completed their turn,\r\n   * which will result in a response `stop_reason` of `\"end_turn\"`.\r\n   *\r\n   * If you want the model to stop generating when it encounters custom strings of\r\n   * text, you can use the `stop_sequences` parameter. If the model encounters one of\r\n   * the custom sequences, the response `stop_reason` value will be `\"stop_sequence\"`\r\n   * and the response `stop_sequence` value will contain the matched stop sequence.\r\n   */\r\n  stop_sequences?: Array<string>;\r\n\r\n  /**\r\n   * Body param: Whether to incrementally stream the response using server-sent\r\n   * events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for\r\n   * details.\r\n   */\r\n  stream?: boolean;\r\n\r\n  /**\r\n   * Body param: System prompt.\r\n   *\r\n   * A system prompt is a way of providing context and instructions to Claude, such\r\n   * as specifying a particular goal or role. See our\r\n   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).\r\n   */\r\n  system?: string | Array<BetaTextBlockParam>;\r\n\r\n  /**\r\n   * Body param: Amount of randomness injected into the response.\r\n   *\r\n   * Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`\r\n   * for analytical / multiple choice, and closer to `1.0` for creative and\r\n   * generative tasks.\r\n   *\r\n   * Note that even with `temperature` of `0.0`, the results will not be fully\r\n   * deterministic.\r\n   */\r\n  temperature?: number;\r\n\r\n  /**\r\n   * Body param: How the model should use the provided tools. The model can use a\r\n   * specific tool, any available tool, or decide by itself.\r\n   */\r\n  tool_choice?: BetaToolChoice;\r\n\r\n  /**\r\n   * Body param: Definitions of tools that the model may use.\r\n   *\r\n   * If you include `tools` in your API request, the model may return `tool_use`\r\n   * content blocks that represent the model's use of those tools. You can then run\r\n   * those tools using the tool input generated by the model and then optionally\r\n   * return results back to the model using `tool_result` content blocks.\r\n   *\r\n   * Each tool definition includes:\r\n   *\r\n   * - `name`: Name of the tool.\r\n   * - `description`: Optional, but strongly-recommended description of the tool.\r\n   * - `input_schema`: [JSON schema](https://json-schema.org/) for the tool `input`\r\n   *   shape that the model will produce in `tool_use` output content blocks.\r\n   *\r\n   * For example, if you defined `tools` as:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"name\": \"get_stock_price\",\r\n   *     \"description\": \"Get the current stock price for a given ticker symbol.\",\r\n   *     \"input_schema\": {\r\n   *       \"type\": \"object\",\r\n   *       \"properties\": {\r\n   *         \"ticker\": {\r\n   *           \"type\": \"string\",\r\n   *           \"description\": \"The stock ticker symbol, e.g. AAPL for Apple Inc.\"\r\n   *         }\r\n   *       },\r\n   *       \"required\": [\"ticker\"]\r\n   *     }\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * And then asked the model \"What's the S&P 500 at today?\", the model might produce\r\n   * `tool_use` content blocks in the response like this:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"type\": \"tool_use\",\r\n   *     \"id\": \"toolu_01D7FLrfh4GYq7yT1ULFeyMV\",\r\n   *     \"name\": \"get_stock_price\",\r\n   *     \"input\": { \"ticker\": \"^GSPC\" }\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * You might then run your `get_stock_price` tool with `{\"ticker\": \"^GSPC\"}` as an\r\n   * input, and return the following back to the model in a subsequent `user`\r\n   * message:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"type\": \"tool_result\",\r\n   *     \"tool_use_id\": \"toolu_01D7FLrfh4GYq7yT1ULFeyMV\",\r\n   *     \"content\": \"259.75 USD\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Tools can be used for workflows that include running client-side tools and\r\n   * functions, or more generally whenever you want the model to produce a particular\r\n   * JSON structure of output.\r\n   *\r\n   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.\r\n   */\r\n  tools?: Array<BetaToolUnion>;\r\n\r\n  /**\r\n   * Body param: Only sample from the top K options for each subsequent token.\r\n   *\r\n   * Used to remove \"long tail\" low probability responses.\r\n   * [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).\r\n   *\r\n   * Recommended for advanced use cases only. You usually only need to use\r\n   * `temperature`.\r\n   */\r\n  top_k?: number;\r\n\r\n  /**\r\n   * Body param: Use nucleus sampling.\r\n   *\r\n   * In nucleus sampling, we compute the cumulative distribution over all the options\r\n   * for each subsequent token in decreasing probability order and cut it off once it\r\n   * reaches a particular probability specified by `top_p`. You should either alter\r\n   * `temperature` or `top_p`, but not both.\r\n   *\r\n   * Recommended for advanced use cases only. You usually only need to use\r\n   * `temperature`.\r\n   */\r\n  top_p?: number;\r\n\r\n  /**\r\n   * Header param: Optional header to specify the beta version(s) you want to use.\r\n   */\r\n  betas?: Array<BetaAPI.AnthropicBeta>;\r\n}\r\n\r\nexport namespace MessageCreateParams {\r\n  export type MessageCreateParamsNonStreaming = MessagesMessagesAPI.MessageCreateParamsNonStreaming;\r\n  export type MessageCreateParamsStreaming = MessagesMessagesAPI.MessageCreateParamsStreaming;\r\n}\r\n\r\nexport interface MessageCreateParamsNonStreaming extends MessageCreateParamsBase {\r\n  /**\r\n   * Body param: Whether to incrementally stream the response using server-sent\r\n   * events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for\r\n   * details.\r\n   */\r\n  stream?: false;\r\n}\r\n\r\nexport interface MessageCreateParamsStreaming extends MessageCreateParamsBase {\r\n  /**\r\n   * Body param: Whether to incrementally stream the response using server-sent\r\n   * events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for\r\n   * details.\r\n   */\r\n  stream: true;\r\n}\r\n\r\nexport interface MessageCountTokensParams {\r\n  /**\r\n   * Body param: Input messages.\r\n   *\r\n   * Our models are trained to operate on alternating `user` and `assistant`\r\n   * conversational turns. When creating a new `Message`, you specify the prior\r\n   * conversational turns with the `messages` parameter, and the model then generates\r\n   * the next `Message` in the conversation. Consecutive `user` or `assistant` turns\r\n   * in your request will be combined into a single turn.\r\n   *\r\n   * Each input message must be an object with a `role` and `content`. You can\r\n   * specify a single `user`-role message, or you can include multiple `user` and\r\n   * `assistant` messages.\r\n   *\r\n   * If the final message uses the `assistant` role, the response content will\r\n   * continue immediately from the content in that message. This can be used to\r\n   * constrain part of the model's response.\r\n   *\r\n   * Example with a single `user` message:\r\n   *\r\n   * ```json\r\n   * [{ \"role\": \"user\", \"content\": \"Hello, Claude\" }]\r\n   * ```\r\n   *\r\n   * Example with multiple conversational turns:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   { \"role\": \"user\", \"content\": \"Hello there.\" },\r\n   *   { \"role\": \"assistant\", \"content\": \"Hi, I'm Claude. How can I help you?\" },\r\n   *   { \"role\": \"user\", \"content\": \"Can you explain LLMs in plain English?\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Example with a partially-filled response from Claude:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"role\": \"user\",\r\n   *     \"content\": \"What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun\"\r\n   *   },\r\n   *   { \"role\": \"assistant\", \"content\": \"The best answer is (\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Each input message `content` may be either a single `string` or an array of\r\n   * content blocks, where each block has a specific `type`. Using a `string` for\r\n   * `content` is shorthand for an array of one content block of type `\"text\"`. The\r\n   * following input messages are equivalent:\r\n   *\r\n   * ```json\r\n   * { \"role\": \"user\", \"content\": \"Hello, Claude\" }\r\n   * ```\r\n   *\r\n   * ```json\r\n   * { \"role\": \"user\", \"content\": [{ \"type\": \"text\", \"text\": \"Hello, Claude\" }] }\r\n   * ```\r\n   *\r\n   * Starting with Claude 3 models, you can also send image content blocks:\r\n   *\r\n   * ```json\r\n   * {\r\n   *   \"role\": \"user\",\r\n   *   \"content\": [\r\n   *     {\r\n   *       \"type\": \"image\",\r\n   *       \"source\": {\r\n   *         \"type\": \"base64\",\r\n   *         \"media_type\": \"image/jpeg\",\r\n   *         \"data\": \"/9j/4AAQSkZJRg...\"\r\n   *       }\r\n   *     },\r\n   *     { \"type\": \"text\", \"text\": \"What is in this image?\" }\r\n   *   ]\r\n   * }\r\n   * ```\r\n   *\r\n   * We currently support the `base64` source type for images, and the `image/jpeg`,\r\n   * `image/png`, `image/gif`, and `image/webp` media types.\r\n   *\r\n   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for\r\n   * more input examples.\r\n   *\r\n   * Note that if you want to include a\r\n   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use\r\n   * the top-level `system` parameter â€” there is no `\"system\"` role for input\r\n   * messages in the Messages API.\r\n   */\r\n  messages: Array<BetaMessageParam>;\r\n\r\n  /**\r\n   * Body param: The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: MessagesAPI.Model;\r\n\r\n  /**\r\n   * Body param: System prompt.\r\n   *\r\n   * A system prompt is a way of providing context and instructions to Claude, such\r\n   * as specifying a particular goal or role. See our\r\n   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).\r\n   */\r\n  system?: string | Array<BetaTextBlockParam>;\r\n\r\n  /**\r\n   * Body param: How the model should use the provided tools. The model can use a\r\n   * specific tool, any available tool, or decide by itself.\r\n   */\r\n  tool_choice?: BetaToolChoice;\r\n\r\n  /**\r\n   * Body param: Definitions of tools that the model may use.\r\n   *\r\n   * If you include `tools` in your API request, the model may return `tool_use`\r\n   * content blocks that represent the model's use of those tools. You can then run\r\n   * those tools using the tool input generated by the model and then optionally\r\n   * return results back to the model using `tool_result` content blocks.\r\n   *\r\n   * Each tool definition includes:\r\n   *\r\n   * - `name`: Name of the tool.\r\n   * - `description`: Optional, but strongly-recommended description of the tool.\r\n   * - `input_schema`: [JSON schema](https://json-schema.org/) for the tool `input`\r\n   *   shape that the model will produce in `tool_use` output content blocks.\r\n   *\r\n   * For example, if you defined `tools` as:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"name\": \"get_stock_price\",\r\n   *     \"description\": \"Get the current stock price for a given ticker symbol.\",\r\n   *     \"input_schema\": {\r\n   *       \"type\": \"object\",\r\n   *       \"properties\": {\r\n   *         \"ticker\": {\r\n   *           \"type\": \"string\",\r\n   *           \"description\": \"The stock ticker symbol, e.g. AAPL for Apple Inc.\"\r\n   *         }\r\n   *       },\r\n   *       \"required\": [\"ticker\"]\r\n   *     }\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * And then asked the model \"What's the S&P 500 at today?\", the model might produce\r\n   * `tool_use` content blocks in the response like this:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"type\": \"tool_use\",\r\n   *     \"id\": \"toolu_01D7FLrfh4GYq7yT1ULFeyMV\",\r\n   *     \"name\": \"get_stock_price\",\r\n   *     \"input\": { \"ticker\": \"^GSPC\" }\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * You might then run your `get_stock_price` tool with `{\"ticker\": \"^GSPC\"}` as an\r\n   * input, and return the following back to the model in a subsequent `user`\r\n   * message:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"type\": \"tool_result\",\r\n   *     \"tool_use_id\": \"toolu_01D7FLrfh4GYq7yT1ULFeyMV\",\r\n   *     \"content\": \"259.75 USD\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Tools can be used for workflows that include running client-side tools and\r\n   * functions, or more generally whenever you want the model to produce a particular\r\n   * JSON structure of output.\r\n   *\r\n   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.\r\n   */\r\n  tools?: Array<BetaTool | BetaToolComputerUse20241022 | BetaToolBash20241022 | BetaToolTextEditor20241022>;\r\n\r\n  /**\r\n   * Header param: Optional header to specify the beta version(s) you want to use.\r\n   */\r\n  betas?: Array<BetaAPI.AnthropicBeta>;\r\n}\r\n\r\nMessages.Batches = Batches;\r\nMessages.BetaMessageBatchesPage = BetaMessageBatchesPage;\r\n\r\nexport declare namespace Messages {\r\n  export {\r\n    type BetaBase64PDFBlock as BetaBase64PDFBlock,\r\n    type BetaBase64PDFSource as BetaBase64PDFSource,\r\n    type BetaCacheControlEphemeral as BetaCacheControlEphemeral,\r\n    type BetaContentBlock as BetaContentBlock,\r\n    type BetaContentBlockParam as BetaContentBlockParam,\r\n    type BetaImageBlockParam as BetaImageBlockParam,\r\n    type BetaInputJSONDelta as BetaInputJSONDelta,\r\n    type BetaMessage as BetaMessage,\r\n    type BetaMessageDeltaUsage as BetaMessageDeltaUsage,\r\n    type BetaMessageParam as BetaMessageParam,\r\n    type BetaMessageTokensCount as BetaMessageTokensCount,\r\n    type BetaMetadata as BetaMetadata,\r\n    type BetaRawContentBlockDeltaEvent as BetaRawContentBlockDeltaEvent,\r\n    type BetaRawContentBlockStartEvent as BetaRawContentBlockStartEvent,\r\n    type BetaRawContentBlockStopEvent as BetaRawContentBlockStopEvent,\r\n    type BetaRawMessageDeltaEvent as BetaRawMessageDeltaEvent,\r\n    type BetaRawMessageStartEvent as BetaRawMessageStartEvent,\r\n    type BetaRawMessageStopEvent as BetaRawMessageStopEvent,\r\n    type BetaRawMessageStreamEvent as BetaRawMessageStreamEvent,\r\n    type BetaTextBlock as BetaTextBlock,\r\n    type BetaTextBlockParam as BetaTextBlockParam,\r\n    type BetaTextDelta as BetaTextDelta,\r\n    type BetaTool as BetaTool,\r\n    type BetaToolBash20241022 as BetaToolBash20241022,\r\n    type BetaToolChoice as BetaToolChoice,\r\n    type BetaToolChoiceAny as BetaToolChoiceAny,\r\n    type BetaToolChoiceAuto as BetaToolChoiceAuto,\r\n    type BetaToolChoiceTool as BetaToolChoiceTool,\r\n    type BetaToolComputerUse20241022 as BetaToolComputerUse20241022,\r\n    type BetaToolResultBlockParam as BetaToolResultBlockParam,\r\n    type BetaToolTextEditor20241022 as BetaToolTextEditor20241022,\r\n    type BetaToolUnion as BetaToolUnion,\r\n    type BetaToolUseBlock as BetaToolUseBlock,\r\n    type BetaToolUseBlockParam as BetaToolUseBlockParam,\r\n    type BetaUsage as BetaUsage,\r\n    type MessageCreateParams as MessageCreateParams,\r\n    type MessageCreateParamsNonStreaming as MessageCreateParamsNonStreaming,\r\n    type MessageCreateParamsStreaming as MessageCreateParamsStreaming,\r\n    type MessageCountTokensParams as MessageCountTokensParams,\r\n  };\r\n\r\n  export {\r\n    Batches as Batches,\r\n    type BetaMessageBatch as BetaMessageBatch,\r\n    type BetaMessageBatchCanceledResult as BetaMessageBatchCanceledResult,\r\n    type BetaMessageBatchErroredResult as BetaMessageBatchErroredResult,\r\n    type BetaMessageBatchExpiredResult as BetaMessageBatchExpiredResult,\r\n    type BetaMessageBatchIndividualResponse as BetaMessageBatchIndividualResponse,\r\n    type BetaMessageBatchRequestCounts as BetaMessageBatchRequestCounts,\r\n    type BetaMessageBatchResult as BetaMessageBatchResult,\r\n    type BetaMessageBatchSucceededResult as BetaMessageBatchSucceededResult,\r\n    BetaMessageBatchesPage as BetaMessageBatchesPage,\r\n    type BatchCreateParams as BatchCreateParams,\r\n    type BatchRetrieveParams as BatchRetrieveParams,\r\n    type BatchListParams as BatchListParams,\r\n    type BatchCancelParams as BatchCancelParams,\r\n    type BatchResultsParams as BatchResultsParams,\r\n  };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from \"../../resource.js\";\r\nimport * as ModelsAPI from \"./models.js\";\r\nimport { BetaModelInfo, BetaModelInfosPage, ModelListParams, Models } from \"./models.js\";\r\nimport * as MessagesAPI from \"./messages/messages.js\";\r\nimport {\r\n  BetaBase64PDFBlock,\r\n  BetaBase64PDFSource,\r\n  BetaCacheControlEphemeral,\r\n  BetaContentBlock,\r\n  BetaContentBlockParam,\r\n  BetaImageBlockParam,\r\n  BetaInputJSONDelta,\r\n  BetaMessage,\r\n  BetaMessageDeltaUsage,\r\n  BetaMessageParam,\r\n  BetaMessageTokensCount,\r\n  BetaMetadata,\r\n  BetaRawContentBlockDeltaEvent,\r\n  BetaRawContentBlockStartEvent,\r\n  BetaRawContentBlockStopEvent,\r\n  BetaRawMessageDeltaEvent,\r\n  BetaRawMessageStartEvent,\r\n  BetaRawMessageStopEvent,\r\n  BetaRawMessageStreamEvent,\r\n  BetaTextBlock,\r\n  BetaTextBlockParam,\r\n  BetaTextDelta,\r\n  BetaTool,\r\n  BetaToolBash20241022,\r\n  BetaToolChoice,\r\n  BetaToolChoiceAny,\r\n  BetaToolChoiceAuto,\r\n  BetaToolChoiceTool,\r\n  BetaToolComputerUse20241022,\r\n  BetaToolResultBlockParam,\r\n  BetaToolTextEditor20241022,\r\n  BetaToolUnion,\r\n  BetaToolUseBlock,\r\n  BetaToolUseBlockParam,\r\n  BetaUsage,\r\n  MessageCountTokensParams,\r\n  MessageCreateParams,\r\n  MessageCreateParamsNonStreaming,\r\n  MessageCreateParamsStreaming,\r\n  Messages,\r\n} from \"./messages/messages.js\";\r\n\r\nexport class Beta extends APIResource {\r\n  models: ModelsAPI.Models = new ModelsAPI.Models(this._client);\r\n  messages: MessagesAPI.Messages = new MessagesAPI.Messages(this._client);\r\n}\r\n\r\nexport type AnthropicBeta =\r\n  | (string & {})\r\n  | 'message-batches-2024-09-24'\r\n  | 'prompt-caching-2024-07-31'\r\n  | 'computer-use-2024-10-22'\r\n  | 'pdfs-2024-09-25'\r\n  | 'token-counting-2024-11-01';\r\n\r\nexport interface BetaAPIError {\r\n  message: string;\r\n\r\n  type: 'api_error';\r\n}\r\n\r\nexport interface BetaAuthenticationError {\r\n  message: string;\r\n\r\n  type: 'authentication_error';\r\n}\r\n\r\nexport interface BetaBillingError {\r\n  message: string;\r\n\r\n  type: 'billing_error';\r\n}\r\n\r\nexport type BetaError =\r\n  | BetaInvalidRequestError\r\n  | BetaAuthenticationError\r\n  | BetaBillingError\r\n  | BetaPermissionError\r\n  | BetaNotFoundError\r\n  | BetaRateLimitError\r\n  | BetaGatewayTimeoutError\r\n  | BetaAPIError\r\n  | BetaOverloadedError;\r\n\r\nexport interface BetaErrorResponse {\r\n  error: BetaError;\r\n\r\n  type: 'error';\r\n}\r\n\r\nexport interface BetaGatewayTimeoutError {\r\n  message: string;\r\n\r\n  type: 'timeout_error';\r\n}\r\n\r\nexport interface BetaInvalidRequestError {\r\n  message: string;\r\n\r\n  type: 'invalid_request_error';\r\n}\r\n\r\nexport interface BetaNotFoundError {\r\n  message: string;\r\n\r\n  type: 'not_found_error';\r\n}\r\n\r\nexport interface BetaOverloadedError {\r\n  message: string;\r\n\r\n  type: 'overloaded_error';\r\n}\r\n\r\nexport interface BetaPermissionError {\r\n  message: string;\r\n\r\n  type: 'permission_error';\r\n}\r\n\r\nexport interface BetaRateLimitError {\r\n  message: string;\r\n\r\n  type: 'rate_limit_error';\r\n}\r\n\r\nBeta.Models = Models;\r\nBeta.BetaModelInfosPage = BetaModelInfosPage;\r\nBeta.Messages = Messages;\r\n\r\nexport declare namespace Beta {\r\n  export {\r\n    type AnthropicBeta as AnthropicBeta,\r\n    type BetaAPIError as BetaAPIError,\r\n    type BetaAuthenticationError as BetaAuthenticationError,\r\n    type BetaBillingError as BetaBillingError,\r\n    type BetaError as BetaError,\r\n    type BetaErrorResponse as BetaErrorResponse,\r\n    type BetaGatewayTimeoutError as BetaGatewayTimeoutError,\r\n    type BetaInvalidRequestError as BetaInvalidRequestError,\r\n    type BetaNotFoundError as BetaNotFoundError,\r\n    type BetaOverloadedError as BetaOverloadedError,\r\n    type BetaPermissionError as BetaPermissionError,\r\n    type BetaRateLimitError as BetaRateLimitError,\r\n  };\r\n\r\n  export {\r\n    Models as Models,\r\n    type BetaModelInfo as BetaModelInfo,\r\n    BetaModelInfosPage as BetaModelInfosPage,\r\n    type ModelListParams as ModelListParams,\r\n  };\r\n\r\n  export {\r\n    Messages as Messages,\r\n    type BetaBase64PDFBlock as BetaBase64PDFBlock,\r\n    type BetaBase64PDFSource as BetaBase64PDFSource,\r\n    type BetaCacheControlEphemeral as BetaCacheControlEphemeral,\r\n    type BetaContentBlock as BetaContentBlock,\r\n    type BetaContentBlockParam as BetaContentBlockParam,\r\n    type BetaImageBlockParam as BetaImageBlockParam,\r\n    type BetaInputJSONDelta as BetaInputJSONDelta,\r\n    type BetaMessage as BetaMessage,\r\n    type BetaMessageDeltaUsage as BetaMessageDeltaUsage,\r\n    type BetaMessageParam as BetaMessageParam,\r\n    type BetaMessageTokensCount as BetaMessageTokensCount,\r\n    type BetaMetadata as BetaMetadata,\r\n    type BetaRawContentBlockDeltaEvent as BetaRawContentBlockDeltaEvent,\r\n    type BetaRawContentBlockStartEvent as BetaRawContentBlockStartEvent,\r\n    type BetaRawContentBlockStopEvent as BetaRawContentBlockStopEvent,\r\n    type BetaRawMessageDeltaEvent as BetaRawMessageDeltaEvent,\r\n    type BetaRawMessageStartEvent as BetaRawMessageStartEvent,\r\n    type BetaRawMessageStopEvent as BetaRawMessageStopEvent,\r\n    type BetaRawMessageStreamEvent as BetaRawMessageStreamEvent,\r\n    type BetaTextBlock as BetaTextBlock,\r\n    type BetaTextBlockParam as BetaTextBlockParam,\r\n    type BetaTextDelta as BetaTextDelta,\r\n    type BetaTool as BetaTool,\r\n    type BetaToolBash20241022 as BetaToolBash20241022,\r\n    type BetaToolChoice as BetaToolChoice,\r\n    type BetaToolChoiceAny as BetaToolChoiceAny,\r\n    type BetaToolChoiceAuto as BetaToolChoiceAuto,\r\n    type BetaToolChoiceTool as BetaToolChoiceTool,\r\n    type BetaToolComputerUse20241022 as BetaToolComputerUse20241022,\r\n    type BetaToolResultBlockParam as BetaToolResultBlockParam,\r\n    type BetaToolTextEditor20241022 as BetaToolTextEditor20241022,\r\n    type BetaToolUnion as BetaToolUnion,\r\n    type BetaToolUseBlock as BetaToolUseBlock,\r\n    type BetaToolUseBlockParam as BetaToolUseBlockParam,\r\n    type BetaUsage as BetaUsage,\r\n    type MessageCreateParams as MessageCreateParams,\r\n    type MessageCreateParamsNonStreaming as MessageCreateParamsNonStreaming,\r\n    type MessageCreateParamsStreaming as MessageCreateParamsStreaming,\r\n    type MessageCountTokensParams as MessageCountTokensParams,\r\n  };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from \"../resource.js\";\r\nimport { APIPromise } from \"../core.js\";\r\nimport * as Core from \"../core.js\";\r\nimport * as CompletionsAPI from \"./completions.js\";\r\nimport * as MessagesAPI from \"./messages/messages.js\";\r\nimport { Stream } from \"../streaming.js\";\r\n\r\nexport class Completions extends APIResource {\r\n  /**\r\n   * [Legacy] Create a Text Completion.\r\n   *\r\n   * The Text Completions API is a legacy API. We recommend using the\r\n   * [Messages API](https://docs.anthropic.com/en/api/messages) going forward.\r\n   *\r\n   * Future models and features will not be compatible with Text Completions. See our\r\n   * [migration guide](https://docs.anthropic.com/en/api/migrating-from-text-completions-to-messages)\r\n   * for guidance in migrating from Text Completions to Messages.\r\n   */\r\n  create(body: CompletionCreateParamsNonStreaming, options?: Core.RequestOptions): APIPromise<Completion>;\r\n  create(\r\n    body: CompletionCreateParamsStreaming,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Stream<Completion>>;\r\n  create(\r\n    body: CompletionCreateParamsBase,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Stream<Completion> | Completion>;\r\n  create(\r\n    body: CompletionCreateParams,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Completion> | APIPromise<Stream<Completion>> {\r\n    return this._client.post('/v1/complete', {\r\n      body,\r\n      timeout: (this._client as any)._options.timeout ?? 600000,\r\n      ...options,\r\n      stream: body.stream ?? false,\r\n    }) as APIPromise<Completion> | APIPromise<Stream<Completion>>;\r\n  }\r\n}\r\n\r\nexport interface Completion {\r\n  /**\r\n   * Unique object identifier.\r\n   *\r\n   * The format and length of IDs may change over time.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * The resulting completion up to and excluding the stop sequences.\r\n   */\r\n  completion: string;\r\n\r\n  /**\r\n   * The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: MessagesAPI.Model;\r\n\r\n  /**\r\n   * The reason that we stopped.\r\n   *\r\n   * This may be one the following values:\r\n   *\r\n   * - `\"stop_sequence\"`: we reached a stop sequence â€” either provided by you via the\r\n   *   `stop_sequences` parameter, or a stop sequence built into the model\r\n   * - `\"max_tokens\"`: we exceeded `max_tokens_to_sample` or the model's maximum\r\n   */\r\n  stop_reason: string | null;\r\n\r\n  /**\r\n   * Object type.\r\n   *\r\n   * For Text Completions, this is always `\"completion\"`.\r\n   */\r\n  type: 'completion';\r\n}\r\n\r\nexport type CompletionCreateParams = CompletionCreateParamsNonStreaming | CompletionCreateParamsStreaming;\r\n\r\nexport interface CompletionCreateParamsBase {\r\n  /**\r\n   * The maximum number of tokens to generate before stopping.\r\n   *\r\n   * Note that our models may stop _before_ reaching this maximum. This parameter\r\n   * only specifies the absolute maximum number of tokens to generate.\r\n   */\r\n  max_tokens_to_sample: number;\r\n\r\n  /**\r\n   * The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: MessagesAPI.Model;\r\n\r\n  /**\r\n   * The prompt that you want Claude to complete.\r\n   *\r\n   * For proper response generation you will need to format your prompt using\r\n   * alternating `\\n\\nHuman:` and `\\n\\nAssistant:` conversational turns. For example:\r\n   *\r\n   * ```\r\n   * \"\\n\\nHuman: {userQuestion}\\n\\nAssistant:\"\r\n   * ```\r\n   *\r\n   * See [prompt validation](https://docs.anthropic.com/en/api/prompt-validation) and\r\n   * our guide to\r\n   * [prompt design](https://docs.anthropic.com/en/docs/intro-to-prompting) for more\r\n   * details.\r\n   */\r\n  prompt: string;\r\n\r\n  /**\r\n   * An object describing metadata about the request.\r\n   */\r\n  metadata?: MessagesAPI.Metadata;\r\n\r\n  /**\r\n   * Sequences that will cause the model to stop generating.\r\n   *\r\n   * Our models stop on `\"\\n\\nHuman:\"`, and may include additional built-in stop\r\n   * sequences in the future. By providing the stop_sequences parameter, you may\r\n   * include additional strings that will cause the model to stop generating.\r\n   */\r\n  stop_sequences?: Array<string>;\r\n\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/streaming) for details.\r\n   */\r\n  stream?: boolean;\r\n\r\n  /**\r\n   * Amount of randomness injected into the response.\r\n   *\r\n   * Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`\r\n   * for analytical / multiple choice, and closer to `1.0` for creative and\r\n   * generative tasks.\r\n   *\r\n   * Note that even with `temperature` of `0.0`, the results will not be fully\r\n   * deterministic.\r\n   */\r\n  temperature?: number;\r\n\r\n  /**\r\n   * Only sample from the top K options for each subsequent token.\r\n   *\r\n   * Used to remove \"long tail\" low probability responses.\r\n   * [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).\r\n   *\r\n   * Recommended for advanced use cases only. You usually only need to use\r\n   * `temperature`.\r\n   */\r\n  top_k?: number;\r\n\r\n  /**\r\n   * Use nucleus sampling.\r\n   *\r\n   * In nucleus sampling, we compute the cumulative distribution over all the options\r\n   * for each subsequent token in decreasing probability order and cut it off once it\r\n   * reaches a particular probability specified by `top_p`. You should either alter\r\n   * `temperature` or `top_p`, but not both.\r\n   *\r\n   * Recommended for advanced use cases only. You usually only need to use\r\n   * `temperature`.\r\n   */\r\n  top_p?: number;\r\n}\r\n\r\nexport namespace CompletionCreateParams {\r\n  /**\r\n   * @deprecated use `Anthropic.Messages.Metadata` instead\r\n   */\r\n  export type Metadata = MessagesAPI.Metadata;\r\n\r\n  export type CompletionCreateParamsNonStreaming = CompletionsAPI.CompletionCreateParamsNonStreaming;\r\n  export type CompletionCreateParamsStreaming = CompletionsAPI.CompletionCreateParamsStreaming;\r\n}\r\n\r\nexport interface CompletionCreateParamsNonStreaming extends CompletionCreateParamsBase {\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/streaming) for details.\r\n   */\r\n  stream?: false;\r\n}\r\n\r\nexport interface CompletionCreateParamsStreaming extends CompletionCreateParamsBase {\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/streaming) for details.\r\n   */\r\n  stream: true;\r\n}\r\n\r\nexport declare namespace Completions {\r\n  export {\r\n    type Completion as Completion,\r\n    type CompletionCreateParams as CompletionCreateParams,\r\n    type CompletionCreateParamsNonStreaming as CompletionCreateParamsNonStreaming,\r\n    type CompletionCreateParamsStreaming as CompletionCreateParamsStreaming,\r\n  };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from \"../../resource.js\";\r\nimport { isRequestOptions } from \"../../core.js\";\r\nimport * as Core from \"../../core.js\";\r\nimport * as Shared from \"../shared.js\";\r\nimport * as MessagesAPI from \"./messages.js\";\r\nimport { Page, type PageParams } from \"../../pagination.js\";\r\nimport { JSONLDecoder } from \"../../internal/decoders/jsonl.js\";\r\nimport { AnthropicError } from \"../../error.js\";\r\n\r\nexport class Batches extends APIResource {\r\n  /**\r\n   * Send a batch of Message creation requests.\r\n   *\r\n   * The Message Batches API can be used to process multiple Messages API requests at\r\n   * once. Once a Message Batch is created, it begins processing immediately. Batches\r\n   * can take up to 24 hours to complete.\r\n   */\r\n  create(body: BatchCreateParams, options?: Core.RequestOptions): Core.APIPromise<MessageBatch> {\r\n    return this._client.post('/v1/messages/batches', { body, ...options });\r\n  }\r\n\r\n  /**\r\n   * This endpoint is idempotent and can be used to poll for Message Batch\r\n   * completion. To access the results of a Message Batch, make a request to the\r\n   * `results_url` field in the response.\r\n   */\r\n  retrieve(messageBatchId: string, options?: Core.RequestOptions): Core.APIPromise<MessageBatch> {\r\n    return this._client.get(`/v1/messages/batches/${messageBatchId}`, options);\r\n  }\r\n\r\n  /**\r\n   * List all Message Batches within a Workspace. Most recently created batches are\r\n   * returned first.\r\n   */\r\n  list(\r\n    query?: BatchListParams,\r\n    options?: Core.RequestOptions,\r\n  ): Core.PagePromise<MessageBatchesPage, MessageBatch>;\r\n  list(options?: Core.RequestOptions): Core.PagePromise<MessageBatchesPage, MessageBatch>;\r\n  list(\r\n    query: BatchListParams | Core.RequestOptions = {},\r\n    options?: Core.RequestOptions,\r\n  ): Core.PagePromise<MessageBatchesPage, MessageBatch> {\r\n    if (isRequestOptions(query)) {\r\n      return this.list({}, query);\r\n    }\r\n    return this._client.getAPIList('/v1/messages/batches', MessageBatchesPage, { query, ...options });\r\n  }\r\n\r\n  /**\r\n   * Batches may be canceled any time before processing ends. Once cancellation is\r\n   * initiated, the batch enters a `canceling` state, at which time the system may\r\n   * complete any in-progress, non-interruptible requests before finalizing\r\n   * cancellation.\r\n   *\r\n   * The number of canceled requests is specified in `request_counts`. To determine\r\n   * which requests were canceled, check the individual results within the batch.\r\n   * Note that cancellation may not result in any canceled requests if they were\r\n   * non-interruptible.\r\n   */\r\n  cancel(messageBatchId: string, options?: Core.RequestOptions): Core.APIPromise<MessageBatch> {\r\n    return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel`, options);\r\n  }\r\n\r\n  /**\r\n   * Streams the results of a Message Batch as a `.jsonl` file.\r\n   *\r\n   * Each line in the file is a JSON object containing the result of a single request\r\n   * in the Message Batch. Results are not guaranteed to be in the same order as\r\n   * requests. Use the `custom_id` field to match results to requests.\r\n   */\r\n  async results(\r\n    messageBatchId: string,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<JSONLDecoder<MessageBatchIndividualResponse>> {\r\n    const batch = await this.retrieve(messageBatchId);\r\n    if (!batch.results_url) {\r\n      throw new AnthropicError(\r\n        `No batch \\`results_url\\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`,\r\n      );\r\n    }\r\n\r\n    return this._client\r\n      .get(batch.results_url, { ...options, __binaryResponse: true })\r\n      ._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));\r\n  }\r\n}\r\n\r\nexport class MessageBatchesPage extends Page<MessageBatch> {}\r\n\r\nexport interface MessageBatch {\r\n  /**\r\n   * Unique object identifier.\r\n   *\r\n   * The format and length of IDs may change over time.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * RFC 3339 datetime string representing the time at which the Message Batch was\r\n   * archived and its results became unavailable.\r\n   */\r\n  archived_at: string | null;\r\n\r\n  /**\r\n   * RFC 3339 datetime string representing the time at which cancellation was\r\n   * initiated for the Message Batch. Specified only if cancellation was initiated.\r\n   */\r\n  cancel_initiated_at: string | null;\r\n\r\n  /**\r\n   * RFC 3339 datetime string representing the time at which the Message Batch was\r\n   * created.\r\n   */\r\n  created_at: string;\r\n\r\n  /**\r\n   * RFC 3339 datetime string representing the time at which processing for the\r\n   * Message Batch ended. Specified only once processing ends.\r\n   *\r\n   * Processing ends when every request in a Message Batch has either succeeded,\r\n   * errored, canceled, or expired.\r\n   */\r\n  ended_at: string | null;\r\n\r\n  /**\r\n   * RFC 3339 datetime string representing the time at which the Message Batch will\r\n   * expire and end processing, which is 24 hours after creation.\r\n   */\r\n  expires_at: string;\r\n\r\n  /**\r\n   * Processing status of the Message Batch.\r\n   */\r\n  processing_status: 'in_progress' | 'canceling' | 'ended';\r\n\r\n  /**\r\n   * Tallies requests within the Message Batch, categorized by their status.\r\n   *\r\n   * Requests start as `processing` and move to one of the other statuses only once\r\n   * processing of the entire batch ends. The sum of all values always matches the\r\n   * total number of requests in the batch.\r\n   */\r\n  request_counts: MessageBatchRequestCounts;\r\n\r\n  /**\r\n   * URL to a `.jsonl` file containing the results of the Message Batch requests.\r\n   * Specified only once processing ends.\r\n   *\r\n   * Results in the file are not guaranteed to be in the same order as requests. Use\r\n   * the `custom_id` field to match results to requests.\r\n   */\r\n  results_url: string | null;\r\n\r\n  /**\r\n   * Object type.\r\n   *\r\n   * For Message Batches, this is always `\"message_batch\"`.\r\n   */\r\n  type: 'message_batch';\r\n}\r\n\r\nexport interface MessageBatchCanceledResult {\r\n  type: 'canceled';\r\n}\r\n\r\nexport interface MessageBatchErroredResult {\r\n  error: Shared.ErrorResponse;\r\n\r\n  type: 'errored';\r\n}\r\n\r\nexport interface MessageBatchExpiredResult {\r\n  type: 'expired';\r\n}\r\n\r\nexport interface MessageBatchIndividualResponse {\r\n  /**\r\n   * Developer-provided ID created for each request in a Message Batch. Useful for\r\n   * matching results to requests, as results may be given out of request order.\r\n   *\r\n   * Must be unique for each request within the Message Batch.\r\n   */\r\n  custom_id: string;\r\n\r\n  /**\r\n   * Processing result for this request.\r\n   *\r\n   * Contains a Message output if processing was successful, an error response if\r\n   * processing failed, or the reason why processing was not attempted, such as\r\n   * cancellation or expiration.\r\n   */\r\n  result: MessageBatchResult;\r\n}\r\n\r\nexport interface MessageBatchRequestCounts {\r\n  /**\r\n   * Number of requests in the Message Batch that have been canceled.\r\n   *\r\n   * This is zero until processing of the entire Message Batch has ended.\r\n   */\r\n  canceled: number;\r\n\r\n  /**\r\n   * Number of requests in the Message Batch that encountered an error.\r\n   *\r\n   * This is zero until processing of the entire Message Batch has ended.\r\n   */\r\n  errored: number;\r\n\r\n  /**\r\n   * Number of requests in the Message Batch that have expired.\r\n   *\r\n   * This is zero until processing of the entire Message Batch has ended.\r\n   */\r\n  expired: number;\r\n\r\n  /**\r\n   * Number of requests in the Message Batch that are processing.\r\n   */\r\n  processing: number;\r\n\r\n  /**\r\n   * Number of requests in the Message Batch that have completed successfully.\r\n   *\r\n   * This is zero until processing of the entire Message Batch has ended.\r\n   */\r\n  succeeded: number;\r\n}\r\n\r\n/**\r\n * Processing result for this request.\r\n *\r\n * Contains a Message output if processing was successful, an error response if\r\n * processing failed, or the reason why processing was not attempted, such as\r\n * cancellation or expiration.\r\n */\r\nexport type MessageBatchResult =\r\n  | MessageBatchSucceededResult\r\n  | MessageBatchErroredResult\r\n  | MessageBatchCanceledResult\r\n  | MessageBatchExpiredResult;\r\n\r\nexport interface MessageBatchSucceededResult {\r\n  message: MessagesAPI.Message;\r\n\r\n  type: 'succeeded';\r\n}\r\n\r\nexport interface BatchCreateParams {\r\n  /**\r\n   * List of requests for prompt completion. Each is an individual request to create\r\n   * a Message.\r\n   */\r\n  requests: Array<BatchCreateParams.Request>;\r\n}\r\n\r\nexport namespace BatchCreateParams {\r\n  export interface Request {\r\n    /**\r\n     * Developer-provided ID created for each request in a Message Batch. Useful for\r\n     * matching results to requests, as results may be given out of request order.\r\n     *\r\n     * Must be unique for each request within the Message Batch.\r\n     */\r\n    custom_id: string;\r\n\r\n    /**\r\n     * Messages API creation parameters for the individual request.\r\n     *\r\n     * See the [Messages API reference](/en/api/messages) for full documentation on\r\n     * available parameters.\r\n     */\r\n    params: MessagesAPI.MessageCreateParamsNonStreaming;\r\n  }\r\n}\r\n\r\nexport interface BatchListParams extends PageParams {}\r\n\r\nBatches.MessageBatchesPage = MessageBatchesPage;\r\n\r\nexport declare namespace Batches {\r\n  export {\r\n    type MessageBatch as MessageBatch,\r\n    type MessageBatchCanceledResult as MessageBatchCanceledResult,\r\n    type MessageBatchErroredResult as MessageBatchErroredResult,\r\n    type MessageBatchExpiredResult as MessageBatchExpiredResult,\r\n    type MessageBatchIndividualResponse as MessageBatchIndividualResponse,\r\n    type MessageBatchRequestCounts as MessageBatchRequestCounts,\r\n    type MessageBatchResult as MessageBatchResult,\r\n    type MessageBatchSucceededResult as MessageBatchSucceededResult,\r\n    MessageBatchesPage as MessageBatchesPage,\r\n    type BatchCreateParams as BatchCreateParams,\r\n    type BatchListParams as BatchListParams,\r\n  };\r\n}\r\n", "type Token = {\r\n  type: string;\r\n  value: string;\r\n};\r\n\r\nconst tokenize = (input: string): Token[] => {\r\n    let current = 0;\r\n    let tokens: Token[] = [];\r\n\r\n    while (current < input.length) {\r\n      let char = input[current];\r\n\r\n      if (char === '\\\\') {\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === '{') {\r\n        tokens.push({\r\n          type: 'brace',\r\n          value: '{',\r\n        });\r\n\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === '}') {\r\n        tokens.push({\r\n          type: 'brace',\r\n          value: '}',\r\n        });\r\n\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === '[') {\r\n        tokens.push({\r\n          type: 'paren',\r\n          value: '[',\r\n        });\r\n\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === ']') {\r\n        tokens.push({\r\n          type: 'paren',\r\n          value: ']',\r\n        });\r\n\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === ':') {\r\n        tokens.push({\r\n          type: 'separator',\r\n          value: ':',\r\n        });\r\n\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === ',') {\r\n        tokens.push({\r\n          type: 'delimiter',\r\n          value: ',',\r\n        });\r\n\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === '\"') {\r\n        let value = '';\r\n        let danglingQuote = false;\r\n\r\n        char = input[++current];\r\n\r\n        while (char !== '\"') {\r\n          if (current === input.length) {\r\n            danglingQuote = true;\r\n            break;\r\n          }\r\n\r\n          if (char === '\\\\') {\r\n            current++;\r\n            if (current === input.length) {\r\n              danglingQuote = true;\r\n              break;\r\n            }\r\n            value += char + input[current];\r\n            char = input[++current];\r\n          } else {\r\n            value += char;\r\n            char = input[++current];\r\n          }\r\n        }\r\n\r\n        char = input[++current];\r\n\r\n        if (!danglingQuote) {\r\n          tokens.push({\r\n            type: 'string',\r\n            value,\r\n          });\r\n        }\r\n        continue;\r\n      }\r\n\r\n      let WHITESPACE = /\\s/;\r\n      if (char && WHITESPACE.test(char)) {\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      let NUMBERS = /[0-9]/;\r\n      if ((char && NUMBERS.test(char)) || char === '-' || char === '.') {\r\n        let value = '';\r\n\r\n        if (char === '-') {\r\n          value += char;\r\n          char = input[++current];\r\n        }\r\n\r\n        while ((char && NUMBERS.test(char)) || char === '.') {\r\n          value += char;\r\n          char = input[++current];\r\n        }\r\n\r\n        tokens.push({\r\n          type: 'number',\r\n          value,\r\n        });\r\n        continue;\r\n      }\r\n\r\n      let LETTERS = /[a-z]/i;\r\n      if (char && LETTERS.test(char)) {\r\n        let value = '';\r\n\r\n        while (char && LETTERS.test(char)) {\r\n          if (current === input.length) {\r\n            break;\r\n          }\r\n          value += char;\r\n          char = input[++current];\r\n        }\r\n\r\n        if (value == 'true' || value == 'false' || value === 'null') {\r\n          tokens.push({\r\n            type: 'name',\r\n            value,\r\n          });\r\n        } else {\r\n          // unknown token, e.g. `nul` which isn't quite `null`\r\n          current++;\r\n          continue;\r\n        }\r\n        continue;\r\n      }\r\n\r\n      current++;\r\n    }\r\n\r\n    return tokens;\r\n  },\r\n  strip = (tokens: Token[]): Token[] => {\r\n    if (tokens.length === 0) {\r\n      return tokens;\r\n    }\r\n\r\n    let lastToken = tokens[tokens.length - 1]!;\r\n\r\n    switch (lastToken.type) {\r\n      case 'separator':\r\n        tokens = tokens.slice(0, tokens.length - 1);\r\n        return strip(tokens);\r\n        break;\r\n      case 'number':\r\n        let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];\r\n        if (lastCharacterOfLastToken === '.' || lastCharacterOfLastToken === '-') {\r\n          tokens = tokens.slice(0, tokens.length - 1);\r\n          return strip(tokens);\r\n        }\r\n      case 'string':\r\n        let tokenBeforeTheLastToken = tokens[tokens.length - 2];\r\n        if (tokenBeforeTheLastToken?.type === 'delimiter') {\r\n          tokens = tokens.slice(0, tokens.length - 1);\r\n          return strip(tokens);\r\n        } else if (tokenBeforeTheLastToken?.type === 'brace' && tokenBeforeTheLastToken.value === '{') {\r\n          tokens = tokens.slice(0, tokens.length - 1);\r\n          return strip(tokens);\r\n        }\r\n        break;\r\n      case 'delimiter':\r\n        tokens = tokens.slice(0, tokens.length - 1);\r\n        return strip(tokens);\r\n        break;\r\n    }\r\n\r\n    return tokens;\r\n  },\r\n  unstrip = (tokens: Token[]): Token[] => {\r\n    let tail: string[] = [];\r\n\r\n    tokens.map((token) => {\r\n      if (token.type === 'brace') {\r\n        if (token.value === '{') {\r\n          tail.push('}');\r\n        } else {\r\n          tail.splice(tail.lastIndexOf('}'), 1);\r\n        }\r\n      }\r\n      if (token.type === 'paren') {\r\n        if (token.value === '[') {\r\n          tail.push(']');\r\n        } else {\r\n          tail.splice(tail.lastIndexOf(']'), 1);\r\n        }\r\n      }\r\n    });\r\n\r\n    if (tail.length > 0) {\r\n      tail.reverse().map((item) => {\r\n        if (item === '}') {\r\n          tokens.push({\r\n            type: 'brace',\r\n            value: '}',\r\n          });\r\n        } else if (item === ']') {\r\n          tokens.push({\r\n            type: 'paren',\r\n            value: ']',\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    return tokens;\r\n  },\r\n  generate = (tokens: Token[]): string => {\r\n    let output = '';\r\n\r\n    tokens.map((token) => {\r\n      switch (token.type) {\r\n        case 'string':\r\n          output += '\"' + token.value + '\"';\r\n          break;\r\n        default:\r\n          output += token.value;\r\n          break;\r\n      }\r\n    });\r\n\r\n    return output;\r\n  },\r\n  partialParse = (input: string): unknown => JSON.parse(generate(unstrip(strip(tokenize(input)))));\r\n\r\nexport { partialParse };\r\n", "import * as Core from \"../core.js\";\r\nimport { AnthropicError, APIUserAbortError } from \"../error.js\";\r\nimport {\r\n  type ContentBlock,\r\n  Messages,\r\n  type Message,\r\n  type MessageStreamEvent,\r\n  type MessageParam,\r\n  type MessageCreateParams,\r\n  type MessageCreateParamsBase,\r\n  type TextBlock,\r\n} from \"../resources/messages.js\";\r\nimport { type ReadableStream } from \"../_shims/index.js\";\r\nimport { Stream } from \"../streaming.js\";\r\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.js\";\r\n\r\nexport interface MessageStreamEvents {\r\n  connect: () => void;\r\n  streamEvent: (event: MessageStreamEvent, snapshot: Message) => void;\r\n  text: (textDelta: string, textSnapshot: string) => void;\r\n  inputJson: (partialJson: string, jsonSnapshot: unknown) => void;\r\n  message: (message: Message) => void;\r\n  contentBlock: (content: ContentBlock) => void;\r\n  finalMessage: (message: Message) => void;\r\n  error: (error: AnthropicError) => void;\r\n  abort: (error: APIUserAbortError) => void;\r\n  end: () => void;\r\n}\r\n\r\ntype MessageStreamEventListeners<Event extends keyof MessageStreamEvents> = {\r\n  listener: MessageStreamEvents[Event];\r\n  once?: boolean;\r\n}[];\r\n\r\nconst JSON_BUF_PROPERTY = '__json_buf';\r\n\r\nexport class MessageStream implements AsyncIterable<MessageStreamEvent> {\r\n  messages: MessageParam[] = [];\r\n  receivedMessages: Message[] = [];\r\n  #currentMessageSnapshot: Message | undefined;\r\n\r\n  controller: AbortController = new AbortController();\r\n\r\n  #connectedPromise: Promise<void>;\r\n  #resolveConnectedPromise: () => void = () => {};\r\n  #rejectConnectedPromise: (error: AnthropicError) => void = () => {};\r\n\r\n  #endPromise: Promise<void>;\r\n  #resolveEndPromise: () => void = () => {};\r\n  #rejectEndPromise: (error: AnthropicError) => void = () => {};\r\n\r\n  #listeners: { [Event in keyof MessageStreamEvents]?: MessageStreamEventListeners<Event> } = {};\r\n\r\n  #ended = false;\r\n  #errored = false;\r\n  #aborted = false;\r\n  #catchingPromiseCreated = false;\r\n\r\n  constructor() {\r\n    this.#connectedPromise = new Promise<void>((resolve, reject) => {\r\n      this.#resolveConnectedPromise = resolve;\r\n      this.#rejectConnectedPromise = reject;\r\n    });\r\n\r\n    this.#endPromise = new Promise<void>((resolve, reject) => {\r\n      this.#resolveEndPromise = resolve;\r\n      this.#rejectEndPromise = reject;\r\n    });\r\n\r\n    // Don't let these promises cause unhandled rejection errors.\r\n    // we will manually cause an unhandled rejection error later\r\n    // if the user hasn't registered any error listener or called\r\n    // any promise-returning method.\r\n    this.#connectedPromise.catch(() => {});\r\n    this.#endPromise.catch(() => {});\r\n  }\r\n\r\n  /**\r\n   * Intended for use on the frontend, consuming a stream produced with\r\n   * `.toReadableStream()` on the backend.\r\n   *\r\n   * Note that messages sent to the model do not appear in `.on('message')`\r\n   * in this context.\r\n   */\r\n  static fromReadableStream(stream: ReadableStream): MessageStream {\r\n    const runner = new MessageStream();\r\n    runner._run(() => runner._fromReadableStream(stream));\r\n    return runner;\r\n  }\r\n\r\n  static createMessage(\r\n    messages: Messages,\r\n    params: MessageCreateParamsBase,\r\n    options?: Core.RequestOptions,\r\n  ): MessageStream {\r\n    const runner = new MessageStream();\r\n    for (const message of params.messages) {\r\n      runner._addMessageParam(message);\r\n    }\r\n    runner._run(() =>\r\n      runner._createMessage(\r\n        messages,\r\n        { ...params, stream: true },\r\n        { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } },\r\n      ),\r\n    );\r\n    return runner;\r\n  }\r\n\r\n  protected _run(executor: () => Promise<any>) {\r\n    executor().then(() => {\r\n      this._emitFinal();\r\n      this._emit('end');\r\n    }, this.#handleError);\r\n  }\r\n\r\n  protected _addMessageParam(message: MessageParam) {\r\n    this.messages.push(message);\r\n  }\r\n\r\n  protected _addMessage(message: Message, emit = true) {\r\n    this.receivedMessages.push(message);\r\n    if (emit) {\r\n      this._emit('message', message);\r\n    }\r\n  }\r\n\r\n  protected async _createMessage(\r\n    messages: Messages,\r\n    params: MessageCreateParams,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<void> {\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n    this.#beginRequest();\r\n    const stream = await messages.create(\r\n      { ...params, stream: true },\r\n      { ...options, signal: this.controller.signal },\r\n    );\r\n    this._connected();\r\n    for await (const event of stream) {\r\n      this.#addStreamEvent(event);\r\n    }\r\n    if (stream.controller.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n    this.#endRequest();\r\n  }\r\n\r\n  protected _connected() {\r\n    if (this.ended) return;\r\n    this.#resolveConnectedPromise();\r\n    this._emit('connect');\r\n  }\r\n\r\n  get ended(): boolean {\r\n    return this.#ended;\r\n  }\r\n\r\n  get errored(): boolean {\r\n    return this.#errored;\r\n  }\r\n\r\n  get aborted(): boolean {\r\n    return this.#aborted;\r\n  }\r\n\r\n  abort() {\r\n    this.controller.abort();\r\n  }\r\n\r\n  /**\r\n   * Adds the listener function to the end of the listeners array for the event.\r\n   * No checks are made to see if the listener has already been added. Multiple calls passing\r\n   * the same combination of event and listener will result in the listener being added, and\r\n   * called, multiple times.\r\n   * @returns this MessageStream, so that calls can be chained\r\n   */\r\n  on<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\r\n    const listeners: MessageStreamEventListeners<Event> =\r\n      this.#listeners[event] || (this.#listeners[event] = []);\r\n    listeners.push({ listener });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes the specified listener from the listener array for the event.\r\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\r\n   * listener has been added multiple times to the listener array for the specified event, then\r\n   * off() must be called multiple times to remove each instance.\r\n   * @returns this MessageStream, so that calls can be chained\r\n   */\r\n  off<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\r\n    const listeners = this.#listeners[event];\r\n    if (!listeners) return this;\r\n    const index = listeners.findIndex((l) => l.listener === listener);\r\n    if (index >= 0) listeners.splice(index, 1);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds a one-time listener function for the event. The next time the event is triggered,\r\n   * this listener is removed and then invoked.\r\n   * @returns this MessageStream, so that calls can be chained\r\n   */\r\n  once<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\r\n    const listeners: MessageStreamEventListeners<Event> =\r\n      this.#listeners[event] || (this.#listeners[event] = []);\r\n    listeners.push({ listener, once: true });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\r\n   * the event is triggered, instead of calling a listener callback.\r\n   * @returns a Promise that resolves the next time given event is triggered,\r\n   * or rejects if an error is emitted.  (If you request the 'error' event,\r\n   * returns a promise that resolves with the error).\r\n   *\r\n   * Example:\r\n   *\r\n   *   const message = await stream.emitted('message') // rejects if the stream errors\r\n   */\r\n  emitted<Event extends keyof MessageStreamEvents>(\r\n    event: Event,\r\n  ): Promise<\r\n    Parameters<MessageStreamEvents[Event]> extends [infer Param] ? Param\r\n    : Parameters<MessageStreamEvents[Event]> extends [] ? void\r\n    : Parameters<MessageStreamEvents[Event]>\r\n  > {\r\n    return new Promise((resolve, reject) => {\r\n      this.#catchingPromiseCreated = true;\r\n      if (event !== 'error') this.once('error', reject);\r\n      this.once(event, resolve as any);\r\n    });\r\n  }\r\n\r\n  async done(): Promise<void> {\r\n    this.#catchingPromiseCreated = true;\r\n    await this.#endPromise;\r\n  }\r\n\r\n  get currentMessage(): Message | undefined {\r\n    return this.#currentMessageSnapshot;\r\n  }\r\n\r\n  #getFinalMessage(): Message {\r\n    if (this.receivedMessages.length === 0) {\r\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\r\n    }\r\n    return this.receivedMessages.at(-1)!;\r\n  }\r\n\r\n  /**\r\n   * @returns a promise that resolves with the the final assistant Message response,\r\n   * or rejects if an error occurred or the stream ended prematurely without producing a Message.\r\n   */\r\n  async finalMessage(): Promise<Message> {\r\n    await this.done();\r\n    return this.#getFinalMessage();\r\n  }\r\n\r\n  #getFinalText(): string {\r\n    if (this.receivedMessages.length === 0) {\r\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\r\n    }\r\n    const textBlocks = this.receivedMessages\r\n      .at(-1)!\r\n      .content.filter((block): block is TextBlock => block.type === 'text')\r\n      .map((block) => block.text);\r\n    if (textBlocks.length === 0) {\r\n      throw new AnthropicError('stream ended without producing a content block with type=text');\r\n    }\r\n    return textBlocks.join(' ');\r\n  }\r\n\r\n  /**\r\n   * @returns a promise that resolves with the the final assistant Message's text response, concatenated\r\n   * together if there are more than one text blocks.\r\n   * Rejects if an error occurred or the stream ended prematurely without producing a Message.\r\n   */\r\n  async finalText(): Promise<string> {\r\n    await this.done();\r\n    return this.#getFinalText();\r\n  }\r\n\r\n  #handleError = (error: unknown) => {\r\n    this.#errored = true;\r\n    if (error instanceof Error && error.name === 'AbortError') {\r\n      error = new APIUserAbortError();\r\n    }\r\n    if (error instanceof APIUserAbortError) {\r\n      this.#aborted = true;\r\n      return this._emit('abort', error);\r\n    }\r\n    if (error instanceof AnthropicError) {\r\n      return this._emit('error', error);\r\n    }\r\n    if (error instanceof Error) {\r\n      const anthropicError: AnthropicError = new AnthropicError(error.message);\r\n      // @ts-ignore\r\n      anthropicError.cause = error;\r\n      return this._emit('error', anthropicError);\r\n    }\r\n    return this._emit('error', new AnthropicError(String(error)));\r\n  };\r\n\r\n  protected _emit<Event extends keyof MessageStreamEvents>(\r\n    event: Event,\r\n    ...args: Parameters<MessageStreamEvents[Event]>\r\n  ) {\r\n    // make sure we don't emit any MessageStreamEvents after end\r\n    if (this.#ended) return;\r\n\r\n    if (event === 'end') {\r\n      this.#ended = true;\r\n      this.#resolveEndPromise();\r\n    }\r\n\r\n    const listeners: MessageStreamEventListeners<Event> | undefined = this.#listeners[event];\r\n    if (listeners) {\r\n      this.#listeners[event] = listeners.filter((l) => !l.once) as any;\r\n      listeners.forEach(({ listener }: any) => listener(...args));\r\n    }\r\n\r\n    if (event === 'abort') {\r\n      const error = args[0] as APIUserAbortError;\r\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\r\n        Promise.reject(error);\r\n      }\r\n      this.#rejectConnectedPromise(error);\r\n      this.#rejectEndPromise(error);\r\n      this._emit('end');\r\n      return;\r\n    }\r\n\r\n    if (event === 'error') {\r\n      // NOTE: _emit('error', error) should only be called from #handleError().\r\n\r\n      const error = args[0] as AnthropicError;\r\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\r\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\r\n        // If you are seeing stack traces here, make sure to handle errors via either:\r\n        // - runner.on('error', () => ...)\r\n        // - await runner.done()\r\n        // - await runner.final...()\r\n        // - etc.\r\n        Promise.reject(error);\r\n      }\r\n      this.#rejectConnectedPromise(error);\r\n      this.#rejectEndPromise(error);\r\n      this._emit('end');\r\n    }\r\n  }\r\n\r\n  protected _emitFinal() {\r\n    const finalMessage = this.receivedMessages.at(-1);\r\n    if (finalMessage) {\r\n      this._emit('finalMessage', this.#getFinalMessage());\r\n    }\r\n  }\r\n\r\n  #beginRequest() {\r\n    if (this.ended) return;\r\n    this.#currentMessageSnapshot = undefined;\r\n  }\r\n  #addStreamEvent(event: MessageStreamEvent) {\r\n    if (this.ended) return;\r\n    const messageSnapshot = this.#accumulateMessage(event);\r\n    this._emit('streamEvent', event, messageSnapshot);\r\n\r\n    switch (event.type) {\r\n      case 'content_block_delta': {\r\n        const content = messageSnapshot.content.at(-1)!;\r\n        if (event.delta.type === 'text_delta' && content.type === 'text') {\r\n          this._emit('text', event.delta.text, content.text || '');\r\n        } else if (event.delta.type === 'input_json_delta' && content.type === 'tool_use') {\r\n          if (content.input) {\r\n            this._emit('inputJson', event.delta.partial_json, content.input);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case 'message_stop': {\r\n        this._addMessageParam(messageSnapshot);\r\n        this._addMessage(messageSnapshot, true);\r\n        break;\r\n      }\r\n      case 'content_block_stop': {\r\n        this._emit('contentBlock', messageSnapshot.content.at(-1)!);\r\n        break;\r\n      }\r\n      case 'message_start': {\r\n        this.#currentMessageSnapshot = messageSnapshot;\r\n        break;\r\n      }\r\n      case 'content_block_start':\r\n      case 'message_delta':\r\n        break;\r\n    }\r\n  }\r\n  #endRequest(): Message {\r\n    if (this.ended) {\r\n      throw new AnthropicError(`stream has ended, this shouldn't happen`);\r\n    }\r\n    const snapshot = this.#currentMessageSnapshot;\r\n    if (!snapshot) {\r\n      throw new AnthropicError(`request ended without sending any chunks`);\r\n    }\r\n    this.#currentMessageSnapshot = undefined;\r\n    return snapshot;\r\n  }\r\n\r\n  protected async _fromReadableStream(\r\n    readableStream: ReadableStream,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<void> {\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n    this.#beginRequest();\r\n    this._connected();\r\n    const stream = Stream.fromReadableStream<MessageStreamEvent>(readableStream, this.controller);\r\n    for await (const event of stream) {\r\n      this.#addStreamEvent(event);\r\n    }\r\n    if (stream.controller.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n    this.#endRequest();\r\n  }\r\n\r\n  /**\r\n   * Mutates this.#currentMessage with the current event. Handling the accumulation of multiple messages\r\n   * will be needed to be handled by the caller, this method will throw if you try to accumulate for multiple\r\n   * messages.\r\n   */\r\n  #accumulateMessage(event: MessageStreamEvent): Message {\r\n    let snapshot = this.#currentMessageSnapshot;\r\n\r\n    if (event.type === 'message_start') {\r\n      if (snapshot) {\r\n        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\r\n      }\r\n      return event.message;\r\n    }\r\n\r\n    if (!snapshot) {\r\n      throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\r\n    }\r\n\r\n    switch (event.type) {\r\n      case 'message_stop':\r\n        return snapshot;\r\n      case 'message_delta':\r\n        snapshot.stop_reason = event.delta.stop_reason;\r\n        snapshot.stop_sequence = event.delta.stop_sequence;\r\n        snapshot.usage.output_tokens = event.usage.output_tokens;\r\n        return snapshot;\r\n      case 'content_block_start':\r\n        snapshot.content.push(event.content_block);\r\n        return snapshot;\r\n      case 'content_block_delta': {\r\n        const snapshotContent = snapshot.content.at(event.index);\r\n        if (snapshotContent?.type === 'text' && event.delta.type === 'text_delta') {\r\n          snapshotContent.text += event.delta.text;\r\n        } else if (snapshotContent?.type === 'tool_use' && event.delta.type === 'input_json_delta') {\r\n          // we need to keep track of the raw JSON string as well so that we can\r\n          // re-parse it for each delta, for now we just store it as an untyped\r\n          // non-enumerable property on the snapshot\r\n          let jsonBuf = (snapshotContent as any)[JSON_BUF_PROPERTY] || '';\r\n          jsonBuf += event.delta.partial_json;\r\n\r\n          Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\r\n            value: jsonBuf,\r\n            enumerable: false,\r\n            writable: true,\r\n          });\r\n\r\n          if (jsonBuf) {\r\n            snapshotContent.input = partialParse(jsonBuf);\r\n          }\r\n        }\r\n        return snapshot;\r\n      }\r\n      case 'content_block_stop':\r\n        return snapshot;\r\n    }\r\n  }\r\n\r\n  [Symbol.asyncIterator](): AsyncIterator<MessageStreamEvent> {\r\n    const pushQueue: MessageStreamEvent[] = [];\r\n    const readQueue: {\r\n      resolve: (chunk: MessageStreamEvent | undefined) => void;\r\n      reject: (error: unknown) => void;\r\n    }[] = [];\r\n    let done = false;\r\n\r\n    this.on('streamEvent', (event) => {\r\n      const reader = readQueue.shift();\r\n      if (reader) {\r\n        reader.resolve(event);\r\n      } else {\r\n        pushQueue.push(event);\r\n      }\r\n    });\r\n\r\n    this.on('end', () => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.resolve(undefined);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    this.on('abort', (err) => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.reject(err);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    this.on('error', (err) => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.reject(err);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    return {\r\n      next: async (): Promise<IteratorResult<MessageStreamEvent>> => {\r\n        if (!pushQueue.length) {\r\n          if (done) {\r\n            return { value: undefined, done: true };\r\n          }\r\n          return new Promise<MessageStreamEvent | undefined>((resolve, reject) =>\r\n            readQueue.push({ resolve, reject }),\r\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\r\n        }\r\n        const chunk = pushQueue.shift()!;\r\n        return { value: chunk, done: false };\r\n      },\r\n      return: async () => {\r\n        this.abort();\r\n        return { value: undefined, done: true };\r\n      },\r\n    };\r\n  }\r\n\r\n  toReadableStream(): ReadableStream {\r\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\r\n    return stream.toReadableStream();\r\n  }\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from \"../../resource.js\";\r\nimport { APIPromise } from \"../../core.js\";\r\nimport * as Core from \"../../core.js\";\r\nimport * as MessagesAPI from \"./messages.js\";\r\nimport * as BatchesAPI from \"./batches.js\";\r\nimport {\r\n  BatchCreateParams,\r\n  BatchListParams,\r\n  Batches,\r\n  MessageBatch,\r\n  MessageBatchCanceledResult,\r\n  MessageBatchErroredResult,\r\n  MessageBatchExpiredResult,\r\n  MessageBatchIndividualResponse,\r\n  MessageBatchRequestCounts,\r\n  MessageBatchResult,\r\n  MessageBatchSucceededResult,\r\n  MessageBatchesPage,\r\n} from \"./batches.js\";\r\nimport { Stream } from \"../../streaming.js\";\r\nimport { MessageStream } from \"../../lib/MessageStream.js\";\r\n\r\nexport { MessageStream } from \"../../lib/MessageStream.js\";\r\n\r\nexport class Messages extends APIResource {\r\n  batches: BatchesAPI.Batches = new BatchesAPI.Batches(this._client);\r\n\r\n  /**\r\n   * Send a structured list of input messages with text and/or image content, and the\r\n   * model will generate the next message in the conversation.\r\n   *\r\n   * The Messages API can be used for either single queries or stateless multi-turn\r\n   * conversations.\r\n   */\r\n  create(body: MessageCreateParamsNonStreaming, options?: Core.RequestOptions): APIPromise<Message>;\r\n  create(\r\n    body: MessageCreateParamsStreaming,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Stream<RawMessageStreamEvent>>;\r\n  create(\r\n    body: MessageCreateParamsBase,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Stream<RawMessageStreamEvent> | Message>;\r\n  create(\r\n    body: MessageCreateParams,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Message> | APIPromise<Stream<RawMessageStreamEvent>> {\r\n    if (body.model in DEPRECATED_MODELS) {\r\n      console.warn(\r\n        `The model '${body.model}' is deprecated and will reach end-of-life on ${\r\n          DEPRECATED_MODELS[body.model]\r\n        }\\nPlease migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`,\r\n      );\r\n    }\r\n    return this._client.post('/v1/messages', {\r\n      body,\r\n      timeout: (this._client as any)._options.timeout ?? 600000,\r\n      ...options,\r\n      stream: body.stream ?? false,\r\n    }) as APIPromise<Message> | APIPromise<Stream<RawMessageStreamEvent>>;\r\n  }\r\n\r\n  /**\r\n   * Create a Message stream\r\n   */\r\n  stream(body: MessageStreamParams, options?: Core.RequestOptions): MessageStream {\r\n    return MessageStream.createMessage(this, body, options);\r\n  }\r\n\r\n  /**\r\n   * Count the number of tokens in a Message.\r\n   *\r\n   * The Token Count API can be used to count the number of tokens in a Message,\r\n   * including tools, images, and documents, without creating it.\r\n   */\r\n  countTokens(\r\n    body: MessageCountTokensParams,\r\n    options?: Core.RequestOptions,\r\n  ): Core.APIPromise<MessageTokensCount> {\r\n    return this._client.post('/v1/messages/count_tokens', { body, ...options });\r\n  }\r\n}\r\n\r\nexport interface Base64PDFSource {\r\n  data: string;\r\n\r\n  media_type: 'application/pdf';\r\n\r\n  type: 'base64';\r\n}\r\n\r\nexport interface CacheControlEphemeral {\r\n  type: 'ephemeral';\r\n}\r\n\r\nexport type ContentBlock = TextBlock | ToolUseBlock;\r\n\r\nexport type ContentBlockDeltaEvent = RawContentBlockDeltaEvent;\r\n\r\nexport type ContentBlockParam =\r\n  | TextBlockParam\r\n  | ImageBlockParam\r\n  | ToolUseBlockParam\r\n  | ToolResultBlockParam\r\n  | DocumentBlockParam;\r\n\r\nexport type ContentBlockStartEvent = RawContentBlockStartEvent;\r\n\r\nexport type ContentBlockStopEvent = RawContentBlockStopEvent;\r\n\r\nexport interface DocumentBlockParam {\r\n  source: Base64PDFSource;\r\n\r\n  type: 'document';\r\n\r\n  cache_control?: CacheControlEphemeral | null;\r\n}\r\n\r\nexport interface ImageBlockParam {\r\n  source: ImageBlockParam.Source;\r\n\r\n  type: 'image';\r\n\r\n  cache_control?: CacheControlEphemeral | null;\r\n}\r\n\r\nexport namespace ImageBlockParam {\r\n  export interface Source {\r\n    data: string;\r\n\r\n    media_type: 'image/jpeg' | 'image/png' | 'image/gif' | 'image/webp';\r\n\r\n    type: 'base64';\r\n  }\r\n}\r\n\r\nexport type InputJsonDelta = InputJSONDelta;\r\n\r\nexport interface InputJSONDelta {\r\n  partial_json: string;\r\n\r\n  type: 'input_json_delta';\r\n}\r\n\r\nexport interface Message {\r\n  /**\r\n   * Unique object identifier.\r\n   *\r\n   * The format and length of IDs may change over time.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * Content generated by the model.\r\n   *\r\n   * This is an array of content blocks, each of which has a `type` that determines\r\n   * its shape.\r\n   *\r\n   * Example:\r\n   *\r\n   * ```json\r\n   * [{ \"type\": \"text\", \"text\": \"Hi, I'm Claude.\" }]\r\n   * ```\r\n   *\r\n   * If the request input `messages` ended with an `assistant` turn, then the\r\n   * response `content` will continue directly from that last turn. You can use this\r\n   * to constrain the model's output.\r\n   *\r\n   * For example, if the input `messages` were:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"role\": \"user\",\r\n   *     \"content\": \"What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun\"\r\n   *   },\r\n   *   { \"role\": \"assistant\", \"content\": \"The best answer is (\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Then the response `content` might be:\r\n   *\r\n   * ```json\r\n   * [{ \"type\": \"text\", \"text\": \"B)\" }]\r\n   * ```\r\n   */\r\n  content: Array<ContentBlock>;\r\n\r\n  /**\r\n   * The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: Model;\r\n\r\n  /**\r\n   * Conversational role of the generated message.\r\n   *\r\n   * This will always be `\"assistant\"`.\r\n   */\r\n  role: 'assistant';\r\n\r\n  /**\r\n   * The reason that we stopped.\r\n   *\r\n   * This may be one the following values:\r\n   *\r\n   * - `\"end_turn\"`: the model reached a natural stopping point\r\n   * - `\"max_tokens\"`: we exceeded the requested `max_tokens` or the model's maximum\r\n   * - `\"stop_sequence\"`: one of your provided custom `stop_sequences` was generated\r\n   * - `\"tool_use\"`: the model invoked one or more tools\r\n   *\r\n   * In non-streaming mode this value is always non-null. In streaming mode, it is\r\n   * null in the `message_start` event and non-null otherwise.\r\n   */\r\n  stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use' | null;\r\n\r\n  /**\r\n   * Which custom stop sequence was generated, if any.\r\n   *\r\n   * This value will be a non-null string if one of your custom stop sequences was\r\n   * generated.\r\n   */\r\n  stop_sequence: string | null;\r\n\r\n  /**\r\n   * Object type.\r\n   *\r\n   * For Messages, this is always `\"message\"`.\r\n   */\r\n  type: 'message';\r\n\r\n  /**\r\n   * Billing and rate-limit usage.\r\n   *\r\n   * Anthropic's API bills and rate-limits by token counts, as tokens represent the\r\n   * underlying cost to our systems.\r\n   *\r\n   * Under the hood, the API transforms requests into a format suitable for the\r\n   * model. The model's output then goes through a parsing stage before becoming an\r\n   * API response. As a result, the token counts in `usage` will not match one-to-one\r\n   * with the exact visible content of an API request or response.\r\n   *\r\n   * For example, `output_tokens` will be non-zero, even for an empty string response\r\n   * from Claude.\r\n   */\r\n  usage: Usage;\r\n}\r\n\r\nexport type MessageDeltaEvent = RawMessageDeltaEvent;\r\n\r\nexport interface MessageDeltaUsage {\r\n  /**\r\n   * The cumulative number of output tokens which were used.\r\n   */\r\n  output_tokens: number;\r\n}\r\n\r\nexport interface MessageParam {\r\n  content: string | Array<ContentBlockParam>;\r\n\r\n  role: 'user' | 'assistant';\r\n}\r\n\r\nexport type MessageStartEvent = RawMessageStartEvent;\r\n\r\nexport type MessageStopEvent = RawMessageStopEvent;\r\n\r\nexport type MessageStreamEvent = RawMessageStreamEvent;\r\n\r\nexport interface MessageTokensCount {\r\n  /**\r\n   * The total number of tokens across the provided list of messages, system prompt,\r\n   * and tools.\r\n   */\r\n  input_tokens: number;\r\n}\r\n\r\nexport interface Metadata {\r\n  /**\r\n   * An external identifier for the user who is associated with the request.\r\n   *\r\n   * This should be a uuid, hash value, or other opaque identifier. Anthropic may use\r\n   * this id to help detect abuse. Do not include any identifying information such as\r\n   * name, email address, or phone number.\r\n   */\r\n  user_id?: string | null;\r\n}\r\n\r\n/**\r\n * The model that will complete your prompt.\\n\\nSee\r\n * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n * details and options.\r\n */\r\nexport type Model =\r\n  | (string & {})\r\n  | 'claude-3-5-haiku-latest'\r\n  | 'claude-3-5-haiku-20241022'\r\n  | 'claude-3-5-sonnet-latest'\r\n  | 'claude-3-5-sonnet-20241022'\r\n  | 'claude-3-5-sonnet-20240620'\r\n  | 'claude-3-opus-latest'\r\n  | 'claude-3-opus-20240229'\r\n  | 'claude-3-sonnet-20240229'\r\n  | 'claude-3-haiku-20240307'\r\n  | 'claude-2.1'\r\n  | 'claude-2.0';\r\n\r\ntype DeprecatedModelsType = {\r\n  [K in Model]?: string;\r\n};\r\n\r\nconst DEPRECATED_MODELS: DeprecatedModelsType = {\r\n  'claude-1.3': 'November 6th, 2024',\r\n  'claude-1.3-100k': 'November 6th, 2024',\r\n  'claude-instant-1.1': 'November 6th, 2024',\r\n  'claude-instant-1.1-100k': 'November 6th, 2024',\r\n  'claude-instant-1.2': 'November 6th, 2024',\r\n};\r\n\r\nexport interface RawContentBlockDeltaEvent {\r\n  delta: TextDelta | InputJSONDelta;\r\n\r\n  index: number;\r\n\r\n  type: 'content_block_delta';\r\n}\r\n\r\nexport interface RawContentBlockStartEvent {\r\n  content_block: TextBlock | ToolUseBlock;\r\n\r\n  index: number;\r\n\r\n  type: 'content_block_start';\r\n}\r\n\r\nexport interface RawContentBlockStopEvent {\r\n  index: number;\r\n\r\n  type: 'content_block_stop';\r\n}\r\n\r\nexport interface RawMessageDeltaEvent {\r\n  delta: RawMessageDeltaEvent.Delta;\r\n\r\n  type: 'message_delta';\r\n\r\n  /**\r\n   * Billing and rate-limit usage.\r\n   *\r\n   * Anthropic's API bills and rate-limits by token counts, as tokens represent the\r\n   * underlying cost to our systems.\r\n   *\r\n   * Under the hood, the API transforms requests into a format suitable for the\r\n   * model. The model's output then goes through a parsing stage before becoming an\r\n   * API response. As a result, the token counts in `usage` will not match one-to-one\r\n   * with the exact visible content of an API request or response.\r\n   *\r\n   * For example, `output_tokens` will be non-zero, even for an empty string response\r\n   * from Claude.\r\n   */\r\n  usage: MessageDeltaUsage;\r\n}\r\n\r\nexport namespace RawMessageDeltaEvent {\r\n  export interface Delta {\r\n    stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use' | null;\r\n\r\n    stop_sequence: string | null;\r\n  }\r\n}\r\n\r\nexport interface RawMessageStartEvent {\r\n  message: Message;\r\n\r\n  type: 'message_start';\r\n}\r\n\r\nexport interface RawMessageStopEvent {\r\n  type: 'message_stop';\r\n}\r\n\r\nexport type RawMessageStreamEvent =\r\n  | RawMessageStartEvent\r\n  | RawMessageDeltaEvent\r\n  | RawMessageStopEvent\r\n  | RawContentBlockStartEvent\r\n  | RawContentBlockDeltaEvent\r\n  | RawContentBlockStopEvent;\r\n\r\nexport interface TextBlock {\r\n  text: string;\r\n\r\n  type: 'text';\r\n}\r\n\r\nexport interface TextBlockParam {\r\n  text: string;\r\n\r\n  type: 'text';\r\n\r\n  cache_control?: CacheControlEphemeral | null;\r\n}\r\n\r\nexport interface TextDelta {\r\n  text: string;\r\n\r\n  type: 'text_delta';\r\n}\r\n\r\nexport interface Tool {\r\n  /**\r\n   * [JSON schema](https://json-schema.org/) for this tool's input.\r\n   *\r\n   * This defines the shape of the `input` that your tool accepts and that the model\r\n   * will produce.\r\n   */\r\n  input_schema: Tool.InputSchema;\r\n\r\n  /**\r\n   * Name of the tool.\r\n   *\r\n   * This is how the tool will be called by the model and in tool_use blocks.\r\n   */\r\n  name: string;\r\n\r\n  cache_control?: CacheControlEphemeral | null;\r\n\r\n  /**\r\n   * Description of what this tool does.\r\n   *\r\n   * Tool descriptions should be as detailed as possible. The more information that\r\n   * the model has about what the tool is and how to use it, the better it will\r\n   * perform. You can use natural language descriptions to reinforce important\r\n   * aspects of the tool input JSON schema.\r\n   */\r\n  description?: string;\r\n}\r\n\r\nexport namespace Tool {\r\n  /**\r\n   * [JSON schema](https://json-schema.org/) for this tool's input.\r\n   *\r\n   * This defines the shape of the `input` that your tool accepts and that the model\r\n   * will produce.\r\n   */\r\n  export interface InputSchema {\r\n    type: 'object';\r\n\r\n    properties?: unknown | null;\r\n    [k: string]: unknown;\r\n  }\r\n}\r\n\r\n/**\r\n * How the model should use the provided tools. The model can use a specific tool,\r\n * any available tool, or decide by itself.\r\n */\r\nexport type ToolChoice = ToolChoiceAuto | ToolChoiceAny | ToolChoiceTool;\r\n\r\n/**\r\n * The model will use any available tools.\r\n */\r\nexport interface ToolChoiceAny {\r\n  type: 'any';\r\n\r\n  /**\r\n   * Whether to disable parallel tool use.\r\n   *\r\n   * Defaults to `false`. If set to `true`, the model will output exactly one tool\r\n   * use.\r\n   */\r\n  disable_parallel_tool_use?: boolean;\r\n}\r\n\r\n/**\r\n * The model will automatically decide whether to use tools.\r\n */\r\nexport interface ToolChoiceAuto {\r\n  type: 'auto';\r\n\r\n  /**\r\n   * Whether to disable parallel tool use.\r\n   *\r\n   * Defaults to `false`. If set to `true`, the model will output at most one tool\r\n   * use.\r\n   */\r\n  disable_parallel_tool_use?: boolean;\r\n}\r\n\r\n/**\r\n * The model will use the specified tool with `tool_choice.name`.\r\n */\r\nexport interface ToolChoiceTool {\r\n  /**\r\n   * The name of the tool to use.\r\n   */\r\n  name: string;\r\n\r\n  type: 'tool';\r\n\r\n  /**\r\n   * Whether to disable parallel tool use.\r\n   *\r\n   * Defaults to `false`. If set to `true`, the model will output exactly one tool\r\n   * use.\r\n   */\r\n  disable_parallel_tool_use?: boolean;\r\n}\r\n\r\nexport interface ToolResultBlockParam {\r\n  tool_use_id: string;\r\n\r\n  type: 'tool_result';\r\n\r\n  cache_control?: CacheControlEphemeral | null;\r\n\r\n  content?: string | Array<TextBlockParam | ImageBlockParam>;\r\n\r\n  is_error?: boolean;\r\n}\r\n\r\nexport interface ToolUseBlock {\r\n  id: string;\r\n\r\n  input: unknown;\r\n\r\n  name: string;\r\n\r\n  type: 'tool_use';\r\n}\r\n\r\nexport interface ToolUseBlockParam {\r\n  id: string;\r\n\r\n  input: unknown;\r\n\r\n  name: string;\r\n\r\n  type: 'tool_use';\r\n\r\n  cache_control?: CacheControlEphemeral | null;\r\n}\r\n\r\nexport interface Usage {\r\n  /**\r\n   * The number of input tokens used to create the cache entry.\r\n   */\r\n  cache_creation_input_tokens: number | null;\r\n\r\n  /**\r\n   * The number of input tokens read from the cache.\r\n   */\r\n  cache_read_input_tokens: number | null;\r\n\r\n  /**\r\n   * The number of input tokens which were used.\r\n   */\r\n  input_tokens: number;\r\n\r\n  /**\r\n   * The number of output tokens which were used.\r\n   */\r\n  output_tokens: number;\r\n}\r\n\r\nexport type MessageCreateParams = MessageCreateParamsNonStreaming | MessageCreateParamsStreaming;\r\n\r\nexport interface MessageCreateParamsBase {\r\n  /**\r\n   * The maximum number of tokens to generate before stopping.\r\n   *\r\n   * Note that our models may stop _before_ reaching this maximum. This parameter\r\n   * only specifies the absolute maximum number of tokens to generate.\r\n   *\r\n   * Different models have different maximum values for this parameter. See\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for details.\r\n   */\r\n  max_tokens: number;\r\n\r\n  /**\r\n   * Input messages.\r\n   *\r\n   * Our models are trained to operate on alternating `user` and `assistant`\r\n   * conversational turns. When creating a new `Message`, you specify the prior\r\n   * conversational turns with the `messages` parameter, and the model then generates\r\n   * the next `Message` in the conversation. Consecutive `user` or `assistant` turns\r\n   * in your request will be combined into a single turn.\r\n   *\r\n   * Each input message must be an object with a `role` and `content`. You can\r\n   * specify a single `user`-role message, or you can include multiple `user` and\r\n   * `assistant` messages.\r\n   *\r\n   * If the final message uses the `assistant` role, the response content will\r\n   * continue immediately from the content in that message. This can be used to\r\n   * constrain part of the model's response.\r\n   *\r\n   * Example with a single `user` message:\r\n   *\r\n   * ```json\r\n   * [{ \"role\": \"user\", \"content\": \"Hello, Claude\" }]\r\n   * ```\r\n   *\r\n   * Example with multiple conversational turns:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   { \"role\": \"user\", \"content\": \"Hello there.\" },\r\n   *   { \"role\": \"assistant\", \"content\": \"Hi, I'm Claude. How can I help you?\" },\r\n   *   { \"role\": \"user\", \"content\": \"Can you explain LLMs in plain English?\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Example with a partially-filled response from Claude:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"role\": \"user\",\r\n   *     \"content\": \"What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun\"\r\n   *   },\r\n   *   { \"role\": \"assistant\", \"content\": \"The best answer is (\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Each input message `content` may be either a single `string` or an array of\r\n   * content blocks, where each block has a specific `type`. Using a `string` for\r\n   * `content` is shorthand for an array of one content block of type `\"text\"`. The\r\n   * following input messages are equivalent:\r\n   *\r\n   * ```json\r\n   * { \"role\": \"user\", \"content\": \"Hello, Claude\" }\r\n   * ```\r\n   *\r\n   * ```json\r\n   * { \"role\": \"user\", \"content\": [{ \"type\": \"text\", \"text\": \"Hello, Claude\" }] }\r\n   * ```\r\n   *\r\n   * Starting with Claude 3 models, you can also send image content blocks:\r\n   *\r\n   * ```json\r\n   * {\r\n   *   \"role\": \"user\",\r\n   *   \"content\": [\r\n   *     {\r\n   *       \"type\": \"image\",\r\n   *       \"source\": {\r\n   *         \"type\": \"base64\",\r\n   *         \"media_type\": \"image/jpeg\",\r\n   *         \"data\": \"/9j/4AAQSkZJRg...\"\r\n   *       }\r\n   *     },\r\n   *     { \"type\": \"text\", \"text\": \"What is in this image?\" }\r\n   *   ]\r\n   * }\r\n   * ```\r\n   *\r\n   * We currently support the `base64` source type for images, and the `image/jpeg`,\r\n   * `image/png`, `image/gif`, and `image/webp` media types.\r\n   *\r\n   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for\r\n   * more input examples.\r\n   *\r\n   * Note that if you want to include a\r\n   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use\r\n   * the top-level `system` parameter â€” there is no `\"system\"` role for input\r\n   * messages in the Messages API.\r\n   */\r\n  messages: Array<MessageParam>;\r\n\r\n  /**\r\n   * The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: Model;\r\n\r\n  /**\r\n   * An object describing metadata about the request.\r\n   */\r\n  metadata?: Metadata;\r\n\r\n  /**\r\n   * Custom text sequences that will cause the model to stop generating.\r\n   *\r\n   * Our models will normally stop when they have naturally completed their turn,\r\n   * which will result in a response `stop_reason` of `\"end_turn\"`.\r\n   *\r\n   * If you want the model to stop generating when it encounters custom strings of\r\n   * text, you can use the `stop_sequences` parameter. If the model encounters one of\r\n   * the custom sequences, the response `stop_reason` value will be `\"stop_sequence\"`\r\n   * and the response `stop_sequence` value will contain the matched stop sequence.\r\n   */\r\n  stop_sequences?: Array<string>;\r\n\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for\r\n   * details.\r\n   */\r\n  stream?: boolean;\r\n\r\n  /**\r\n   * System prompt.\r\n   *\r\n   * A system prompt is a way of providing context and instructions to Claude, such\r\n   * as specifying a particular goal or role. See our\r\n   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).\r\n   */\r\n  system?: string | Array<TextBlockParam>;\r\n\r\n  /**\r\n   * Amount of randomness injected into the response.\r\n   *\r\n   * Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`\r\n   * for analytical / multiple choice, and closer to `1.0` for creative and\r\n   * generative tasks.\r\n   *\r\n   * Note that even with `temperature` of `0.0`, the results will not be fully\r\n   * deterministic.\r\n   */\r\n  temperature?: number;\r\n\r\n  /**\r\n   * How the model should use the provided tools. The model can use a specific tool,\r\n   * any available tool, or decide by itself.\r\n   */\r\n  tool_choice?: ToolChoice;\r\n\r\n  /**\r\n   * Definitions of tools that the model may use.\r\n   *\r\n   * If you include `tools` in your API request, the model may return `tool_use`\r\n   * content blocks that represent the model's use of those tools. You can then run\r\n   * those tools using the tool input generated by the model and then optionally\r\n   * return results back to the model using `tool_result` content blocks.\r\n   *\r\n   * Each tool definition includes:\r\n   *\r\n   * - `name`: Name of the tool.\r\n   * - `description`: Optional, but strongly-recommended description of the tool.\r\n   * - `input_schema`: [JSON schema](https://json-schema.org/) for the tool `input`\r\n   *   shape that the model will produce in `tool_use` output content blocks.\r\n   *\r\n   * For example, if you defined `tools` as:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"name\": \"get_stock_price\",\r\n   *     \"description\": \"Get the current stock price for a given ticker symbol.\",\r\n   *     \"input_schema\": {\r\n   *       \"type\": \"object\",\r\n   *       \"properties\": {\r\n   *         \"ticker\": {\r\n   *           \"type\": \"string\",\r\n   *           \"description\": \"The stock ticker symbol, e.g. AAPL for Apple Inc.\"\r\n   *         }\r\n   *       },\r\n   *       \"required\": [\"ticker\"]\r\n   *     }\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * And then asked the model \"What's the S&P 500 at today?\", the model might produce\r\n   * `tool_use` content blocks in the response like this:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"type\": \"tool_use\",\r\n   *     \"id\": \"toolu_01D7FLrfh4GYq7yT1ULFeyMV\",\r\n   *     \"name\": \"get_stock_price\",\r\n   *     \"input\": { \"ticker\": \"^GSPC\" }\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * You might then run your `get_stock_price` tool with `{\"ticker\": \"^GSPC\"}` as an\r\n   * input, and return the following back to the model in a subsequent `user`\r\n   * message:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"type\": \"tool_result\",\r\n   *     \"tool_use_id\": \"toolu_01D7FLrfh4GYq7yT1ULFeyMV\",\r\n   *     \"content\": \"259.75 USD\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Tools can be used for workflows that include running client-side tools and\r\n   * functions, or more generally whenever you want the model to produce a particular\r\n   * JSON structure of output.\r\n   *\r\n   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.\r\n   */\r\n  tools?: Array<Tool>;\r\n\r\n  /**\r\n   * Only sample from the top K options for each subsequent token.\r\n   *\r\n   * Used to remove \"long tail\" low probability responses.\r\n   * [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).\r\n   *\r\n   * Recommended for advanced use cases only. You usually only need to use\r\n   * `temperature`.\r\n   */\r\n  top_k?: number;\r\n\r\n  /**\r\n   * Use nucleus sampling.\r\n   *\r\n   * In nucleus sampling, we compute the cumulative distribution over all the options\r\n   * for each subsequent token in decreasing probability order and cut it off once it\r\n   * reaches a particular probability specified by `top_p`. You should either alter\r\n   * `temperature` or `top_p`, but not both.\r\n   *\r\n   * Recommended for advanced use cases only. You usually only need to use\r\n   * `temperature`.\r\n   */\r\n  top_p?: number;\r\n}\r\n\r\nexport namespace MessageCreateParams {\r\n  /**\r\n   * @deprecated use `Anthropic.Messages.ToolChoiceAuto` instead\r\n   */\r\n  export type Metadata = MessagesAPI.Metadata;\r\n\r\n  /**\r\n   * @deprecated use `Anthropic.Messages.ToolChoiceAuto` instead\r\n   */\r\n  export type ToolChoiceAuto = MessagesAPI.ToolChoiceAuto;\r\n\r\n  /**\r\n   * @deprecated use `Anthropic.Messages.ToolChoiceAny` instead\r\n   */\r\n  export type ToolChoiceAny = MessagesAPI.ToolChoiceAny;\r\n\r\n  /**\r\n   * @deprecated use `Anthropic.Messages.ToolChoiceTool` instead\r\n   */\r\n  export type ToolChoiceTool = MessagesAPI.ToolChoiceTool;\r\n\r\n  export type MessageCreateParamsNonStreaming = MessagesAPI.MessageCreateParamsNonStreaming;\r\n  export type MessageCreateParamsStreaming = MessagesAPI.MessageCreateParamsStreaming;\r\n}\r\n\r\nexport interface MessageCreateParamsNonStreaming extends MessageCreateParamsBase {\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for\r\n   * details.\r\n   */\r\n  stream?: false;\r\n}\r\n\r\nexport interface MessageCreateParamsStreaming extends MessageCreateParamsBase {\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for\r\n   * details.\r\n   */\r\n  stream: true;\r\n}\r\n\r\nexport type MessageStreamParams = MessageCreateParamsBase;\r\n\r\nexport interface MessageCountTokensParams {\r\n  /**\r\n   * Input messages.\r\n   *\r\n   * Our models are trained to operate on alternating `user` and `assistant`\r\n   * conversational turns. When creating a new `Message`, you specify the prior\r\n   * conversational turns with the `messages` parameter, and the model then generates\r\n   * the next `Message` in the conversation. Consecutive `user` or `assistant` turns\r\n   * in your request will be combined into a single turn.\r\n   *\r\n   * Each input message must be an object with a `role` and `content`. You can\r\n   * specify a single `user`-role message, or you can include multiple `user` and\r\n   * `assistant` messages.\r\n   *\r\n   * If the final message uses the `assistant` role, the response content will\r\n   * continue immediately from the content in that message. This can be used to\r\n   * constrain part of the model's response.\r\n   *\r\n   * Example with a single `user` message:\r\n   *\r\n   * ```json\r\n   * [{ \"role\": \"user\", \"content\": \"Hello, Claude\" }]\r\n   * ```\r\n   *\r\n   * Example with multiple conversational turns:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   { \"role\": \"user\", \"content\": \"Hello there.\" },\r\n   *   { \"role\": \"assistant\", \"content\": \"Hi, I'm Claude. How can I help you?\" },\r\n   *   { \"role\": \"user\", \"content\": \"Can you explain LLMs in plain English?\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Example with a partially-filled response from Claude:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"role\": \"user\",\r\n   *     \"content\": \"What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun\"\r\n   *   },\r\n   *   { \"role\": \"assistant\", \"content\": \"The best answer is (\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Each input message `content` may be either a single `string` or an array of\r\n   * content blocks, where each block has a specific `type`. Using a `string` for\r\n   * `content` is shorthand for an array of one content block of type `\"text\"`. The\r\n   * following input messages are equivalent:\r\n   *\r\n   * ```json\r\n   * { \"role\": \"user\", \"content\": \"Hello, Claude\" }\r\n   * ```\r\n   *\r\n   * ```json\r\n   * { \"role\": \"user\", \"content\": [{ \"type\": \"text\", \"text\": \"Hello, Claude\" }] }\r\n   * ```\r\n   *\r\n   * Starting with Claude 3 models, you can also send image content blocks:\r\n   *\r\n   * ```json\r\n   * {\r\n   *   \"role\": \"user\",\r\n   *   \"content\": [\r\n   *     {\r\n   *       \"type\": \"image\",\r\n   *       \"source\": {\r\n   *         \"type\": \"base64\",\r\n   *         \"media_type\": \"image/jpeg\",\r\n   *         \"data\": \"/9j/4AAQSkZJRg...\"\r\n   *       }\r\n   *     },\r\n   *     { \"type\": \"text\", \"text\": \"What is in this image?\" }\r\n   *   ]\r\n   * }\r\n   * ```\r\n   *\r\n   * We currently support the `base64` source type for images, and the `image/jpeg`,\r\n   * `image/png`, `image/gif`, and `image/webp` media types.\r\n   *\r\n   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for\r\n   * more input examples.\r\n   *\r\n   * Note that if you want to include a\r\n   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use\r\n   * the top-level `system` parameter â€” there is no `\"system\"` role for input\r\n   * messages in the Messages API.\r\n   */\r\n  messages: Array<MessageParam>;\r\n\r\n  /**\r\n   * The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: Model;\r\n\r\n  /**\r\n   * System prompt.\r\n   *\r\n   * A system prompt is a way of providing context and instructions to Claude, such\r\n   * as specifying a particular goal or role. See our\r\n   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).\r\n   */\r\n  system?: string | Array<TextBlockParam>;\r\n\r\n  /**\r\n   * How the model should use the provided tools. The model can use a specific tool,\r\n   * any available tool, or decide by itself.\r\n   */\r\n  tool_choice?: ToolChoice;\r\n\r\n  /**\r\n   * Definitions of tools that the model may use.\r\n   *\r\n   * If you include `tools` in your API request, the model may return `tool_use`\r\n   * content blocks that represent the model's use of those tools. You can then run\r\n   * those tools using the tool input generated by the model and then optionally\r\n   * return results back to the model using `tool_result` content blocks.\r\n   *\r\n   * Each tool definition includes:\r\n   *\r\n   * - `name`: Name of the tool.\r\n   * - `description`: Optional, but strongly-recommended description of the tool.\r\n   * - `input_schema`: [JSON schema](https://json-schema.org/) for the tool `input`\r\n   *   shape that the model will produce in `tool_use` output content blocks.\r\n   *\r\n   * For example, if you defined `tools` as:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"name\": \"get_stock_price\",\r\n   *     \"description\": \"Get the current stock price for a given ticker symbol.\",\r\n   *     \"input_schema\": {\r\n   *       \"type\": \"object\",\r\n   *       \"properties\": {\r\n   *         \"ticker\": {\r\n   *           \"type\": \"string\",\r\n   *           \"description\": \"The stock ticker symbol, e.g. AAPL for Apple Inc.\"\r\n   *         }\r\n   *       },\r\n   *       \"required\": [\"ticker\"]\r\n   *     }\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * And then asked the model \"What's the S&P 500 at today?\", the model might produce\r\n   * `tool_use` content blocks in the response like this:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"type\": \"tool_use\",\r\n   *     \"id\": \"toolu_01D7FLrfh4GYq7yT1ULFeyMV\",\r\n   *     \"name\": \"get_stock_price\",\r\n   *     \"input\": { \"ticker\": \"^GSPC\" }\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * You might then run your `get_stock_price` tool with `{\"ticker\": \"^GSPC\"}` as an\r\n   * input, and return the following back to the model in a subsequent `user`\r\n   * message:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"type\": \"tool_result\",\r\n   *     \"tool_use_id\": \"toolu_01D7FLrfh4GYq7yT1ULFeyMV\",\r\n   *     \"content\": \"259.75 USD\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Tools can be used for workflows that include running client-side tools and\r\n   * functions, or more generally whenever you want the model to produce a particular\r\n   * JSON structure of output.\r\n   *\r\n   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.\r\n   */\r\n  tools?: Array<Tool>;\r\n}\r\n\r\nMessages.Batches = Batches;\r\nMessages.MessageBatchesPage = MessageBatchesPage;\r\n\r\nexport declare namespace Messages {\r\n  export {\r\n    type Base64PDFSource as Base64PDFSource,\r\n    type CacheControlEphemeral as CacheControlEphemeral,\r\n    type ContentBlock as ContentBlock,\r\n    type ContentBlockDeltaEvent as ContentBlockDeltaEvent,\r\n    type ContentBlockParam as ContentBlockParam,\r\n    type ContentBlockStartEvent as ContentBlockStartEvent,\r\n    type ContentBlockStopEvent as ContentBlockStopEvent,\r\n    type DocumentBlockParam as DocumentBlockParam,\r\n    type ImageBlockParam as ImageBlockParam,\r\n    type InputJsonDelta as InputJsonDelta,\r\n    type InputJSONDelta as InputJSONDelta,\r\n    type Message as Message,\r\n    type MessageDeltaEvent as MessageDeltaEvent,\r\n    type MessageDeltaUsage as MessageDeltaUsage,\r\n    type MessageParam as MessageParam,\r\n    type MessageStartEvent as MessageStartEvent,\r\n    type MessageStopEvent as MessageStopEvent,\r\n    type MessageStreamEvent as MessageStreamEvent,\r\n    type MessageTokensCount as MessageTokensCount,\r\n    type Metadata as Metadata,\r\n    type Model as Model,\r\n    type RawContentBlockDeltaEvent as RawContentBlockDeltaEvent,\r\n    type RawContentBlockStartEvent as RawContentBlockStartEvent,\r\n    type RawContentBlockStopEvent as RawContentBlockStopEvent,\r\n    type RawMessageDeltaEvent as RawMessageDeltaEvent,\r\n    type RawMessageStartEvent as RawMessageStartEvent,\r\n    type RawMessageStopEvent as RawMessageStopEvent,\r\n    type RawMessageStreamEvent as RawMessageStreamEvent,\r\n    type TextBlock as TextBlock,\r\n    type TextBlockParam as TextBlockParam,\r\n    type TextDelta as TextDelta,\r\n    type Tool as Tool,\r\n    type ToolChoice as ToolChoice,\r\n    type ToolChoiceAny as ToolChoiceAny,\r\n    type ToolChoiceAuto as ToolChoiceAuto,\r\n    type ToolChoiceTool as ToolChoiceTool,\r\n    type ToolResultBlockParam as ToolResultBlockParam,\r\n    type ToolUseBlock as ToolUseBlock,\r\n    type ToolUseBlockParam as ToolUseBlockParam,\r\n    type Usage as Usage,\r\n    type MessageCreateParams as MessageCreateParams,\r\n    type MessageCreateParamsNonStreaming as MessageCreateParamsNonStreaming,\r\n    type MessageCreateParamsStreaming as MessageCreateParamsStreaming,\r\n    type MessageStreamParams as MessageStreamParams,\r\n    type MessageCountTokensParams as MessageCountTokensParams,\r\n  };\r\n\r\n  export {\r\n    Batches as Batches,\r\n    type MessageBatch as MessageBatch,\r\n    type MessageBatchCanceledResult as MessageBatchCanceledResult,\r\n    type MessageBatchErroredResult as MessageBatchErroredResult,\r\n    type MessageBatchExpiredResult as MessageBatchExpiredResult,\r\n    type MessageBatchIndividualResponse as MessageBatchIndividualResponse,\r\n    type MessageBatchRequestCounts as MessageBatchRequestCounts,\r\n    type MessageBatchResult as MessageBatchResult,\r\n    type MessageBatchSucceededResult as MessageBatchSucceededResult,\r\n    MessageBatchesPage as MessageBatchesPage,\r\n    type BatchCreateParams as BatchCreateParams,\r\n    type BatchListParams as BatchListParams,\r\n  };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from \"../resource.js\";\r\nimport { isRequestOptions } from \"../core.js\";\r\nimport * as Core from \"../core.js\";\r\nimport { Page, type PageParams } from \"../pagination.js\";\r\n\r\nexport class Models extends APIResource {\r\n  /**\r\n   * Get a specific model.\r\n   *\r\n   * The Models API response can be used to determine information about a specific\r\n   * model or resolve a model alias to a model ID.\r\n   */\r\n  retrieve(modelId: string, options?: Core.RequestOptions): Core.APIPromise<ModelInfo> {\r\n    return this._client.get(`/v1/models/${modelId}`, options);\r\n  }\r\n\r\n  /**\r\n   * List available models.\r\n   *\r\n   * The Models API response can be used to determine which models are available for\r\n   * use in the API. More recently released models are listed first.\r\n   */\r\n  list(query?: ModelListParams, options?: Core.RequestOptions): Core.PagePromise<ModelInfosPage, ModelInfo>;\r\n  list(options?: Core.RequestOptions): Core.PagePromise<ModelInfosPage, ModelInfo>;\r\n  list(\r\n    query: ModelListParams | Core.RequestOptions = {},\r\n    options?: Core.RequestOptions,\r\n  ): Core.PagePromise<ModelInfosPage, ModelInfo> {\r\n    if (isRequestOptions(query)) {\r\n      return this.list({}, query);\r\n    }\r\n    return this._client.getAPIList('/v1/models', ModelInfosPage, { query, ...options });\r\n  }\r\n}\r\n\r\nexport class ModelInfosPage extends Page<ModelInfo> {}\r\n\r\nexport interface ModelInfo {\r\n  /**\r\n   * Unique model identifier.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * RFC 3339 datetime string representing the time at which the model was released.\r\n   * May be set to an epoch value if the release date is unknown.\r\n   */\r\n  created_at: string;\r\n\r\n  /**\r\n   * A human-readable name for the model.\r\n   */\r\n  display_name: string;\r\n\r\n  /**\r\n   * Object type.\r\n   *\r\n   * For Models, this is always `\"model\"`.\r\n   */\r\n  type: 'model';\r\n}\r\n\r\nexport interface ModelListParams extends PageParams {}\r\n\r\nModels.ModelInfosPage = ModelInfosPage;\r\n\r\nexport declare namespace Models {\r\n  export {\r\n    type ModelInfo as ModelInfo,\r\n    ModelInfosPage as ModelInfosPage,\r\n    type ModelListParams as ModelListParams,\r\n  };\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { type Agent } from \"./_shims/index.js\";\r\nimport * as Core from \"./core.js\";\r\nimport * as Errors from \"./error.js\";\r\nimport * as Pagination from \"./pagination.js\";\r\nimport { type PageParams, PageResponse } from \"./pagination.js\";\r\nimport * as Uploads from \"./uploads.js\";\r\nimport * as API from \"./resources/index.js\";\r\nimport {\r\n  Completion,\r\n  CompletionCreateParams,\r\n  CompletionCreateParamsNonStreaming,\r\n  CompletionCreateParamsStreaming,\r\n  Completions,\r\n} from \"./resources/completions.js\";\r\nimport { ModelInfo, ModelInfosPage, ModelListParams, Models } from \"./resources/models.js\";\r\nimport {\r\n  AnthropicBeta,\r\n  Beta,\r\n  BetaAPIError,\r\n  BetaAuthenticationError,\r\n  BetaBillingError,\r\n  BetaError,\r\n  BetaErrorResponse,\r\n  BetaGatewayTimeoutError,\r\n  BetaInvalidRequestError,\r\n  BetaNotFoundError,\r\n  BetaOverloadedError,\r\n  BetaPermissionError,\r\n  BetaRateLimitError,\r\n} from \"./resources/beta/beta.js\";\r\nimport {\r\n  Base64PDFSource,\r\n  CacheControlEphemeral,\r\n  ContentBlock,\r\n  ContentBlockDeltaEvent,\r\n  ContentBlockParam,\r\n  ContentBlockStartEvent,\r\n  ContentBlockStopEvent,\r\n  DocumentBlockParam,\r\n  ImageBlockParam,\r\n  InputJSONDelta,\r\n  Message,\r\n  MessageCountTokensParams,\r\n  MessageCreateParams,\r\n  MessageCreateParamsNonStreaming,\r\n  MessageCreateParamsStreaming,\r\n  MessageDeltaEvent,\r\n  MessageDeltaUsage,\r\n  MessageParam,\r\n  MessageStartEvent,\r\n  MessageStopEvent,\r\n  MessageStreamEvent,\r\n  MessageStreamParams,\r\n  MessageTokensCount,\r\n  Messages,\r\n  Metadata,\r\n  Model,\r\n  RawContentBlockDeltaEvent,\r\n  RawContentBlockStartEvent,\r\n  RawContentBlockStopEvent,\r\n  RawMessageDeltaEvent,\r\n  RawMessageStartEvent,\r\n  RawMessageStopEvent,\r\n  RawMessageStreamEvent,\r\n  TextBlock,\r\n  TextBlockParam,\r\n  TextDelta,\r\n  Tool,\r\n  ToolChoice,\r\n  ToolChoiceAny,\r\n  ToolChoiceAuto,\r\n  ToolChoiceTool,\r\n  ToolResultBlockParam,\r\n  ToolUseBlock,\r\n  ToolUseBlockParam,\r\n  Usage,\r\n} from \"./resources/messages/messages.js\";\r\n\r\nexport interface ClientOptions {\r\n  /**\r\n   * Defaults to process.env['ANTHROPIC_API_KEY'].\r\n   */\r\n  apiKey?: string | null | undefined;\r\n\r\n  /**\r\n   * Defaults to process.env['ANTHROPIC_AUTH_TOKEN'].\r\n   */\r\n  authToken?: string | null | undefined;\r\n\r\n  /**\r\n   * Override the default base URL for the API, e.g., \"https://api.example.com/v2/\"\r\n   *\r\n   * Defaults to process.env['ANTHROPIC_BASE_URL'].\r\n   */\r\n  baseURL?: string | null | undefined;\r\n\r\n  /**\r\n   * The maximum amount of time (in milliseconds) that the client should wait for a response\r\n   * from the server before timing out a single request.\r\n   *\r\n   * Note that request timeouts are retried by default, so in a worst-case scenario you may wait\r\n   * much longer than this timeout before the promise succeeds or fails.\r\n   */\r\n  timeout?: number;\r\n\r\n  /**\r\n   * An HTTP agent used to manage HTTP(S) connections.\r\n   *\r\n   * If not provided, an agent will be constructed by default in the Node.js environment,\r\n   * otherwise no agent is used.\r\n   */\r\n  httpAgent?: Agent;\r\n\r\n  /**\r\n   * Specify a custom `fetch` function implementation.\r\n   *\r\n   * If not provided, we use `node-fetch` on Node.js and otherwise expect that `fetch` is\r\n   * defined globally.\r\n   */\r\n  fetch?: Core.Fetch | undefined;\r\n\r\n  /**\r\n   * The maximum number of times that the client will retry a request in case of a\r\n   * temporary failure, like a network error or a 5XX error from the server.\r\n   *\r\n   * @default 2\r\n   */\r\n  maxRetries?: number;\r\n\r\n  /**\r\n   * Default headers to include with every request to the API.\r\n   *\r\n   * These can be removed in individual requests by explicitly setting the\r\n   * header to `undefined` or `null` in request options.\r\n   */\r\n  defaultHeaders?: Core.Headers;\r\n\r\n  /**\r\n   * Default query parameters to include with every request to the API.\r\n   *\r\n   * These can be removed in individual requests by explicitly setting the\r\n   * param to `undefined` in request options.\r\n   */\r\n  defaultQuery?: Core.DefaultQuery;\r\n\r\n  /**\r\n   * By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\r\n   * Only set this option to `true` if you understand the risks and have appropriate mitigations in place.\r\n   */\r\n  dangerouslyAllowBrowser?: boolean;\r\n}\r\n\r\n/**\r\n * API Client for interfacing with the Anthropic API.\r\n */\r\nexport class Anthropic extends Core.APIClient {\r\n  apiKey: string | null;\r\n  authToken: string | null;\r\n\r\n  private _options: ClientOptions;\r\n\r\n  /**\r\n   * API Client for interfacing with the Anthropic API.\r\n   *\r\n   * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]\r\n   * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]\r\n   * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.\r\n   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\r\n   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\r\n   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\r\n   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\r\n   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\r\n   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\r\n   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\r\n   */\r\n  constructor({\r\n    baseURL = Core.readEnv('ANTHROPIC_BASE_URL'),\r\n    apiKey = Core.readEnv('ANTHROPIC_API_KEY') ?? null,\r\n    authToken = Core.readEnv('ANTHROPIC_AUTH_TOKEN') ?? null,\r\n    ...opts\r\n  }: ClientOptions = {}) {\r\n    const options: ClientOptions = {\r\n      apiKey,\r\n      authToken,\r\n      ...opts,\r\n      baseURL: baseURL || `https://api.anthropic.com`,\r\n    };\r\n\r\n    if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) {\r\n      throw new Errors.AnthropicError(\r\n        \"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\\n\",\r\n      );\r\n    }\r\n\r\n    super({\r\n      baseURL: options.baseURL!,\r\n      timeout: options.timeout ?? 600000 /* 10 minutes */,\r\n      httpAgent: options.httpAgent,\r\n      maxRetries: options.maxRetries,\r\n      fetch: options.fetch,\r\n    });\r\n\r\n    this._options = options;\r\n\r\n    this.apiKey = apiKey;\r\n    this.authToken = authToken;\r\n  }\r\n\r\n  completions: API.Completions = new API.Completions(this);\r\n  messages: API.Messages = new API.Messages(this);\r\n  models: API.Models = new API.Models(this);\r\n  beta: API.Beta = new API.Beta(this);\r\n\r\n  protected override defaultQuery(): Core.DefaultQuery | undefined {\r\n    return this._options.defaultQuery;\r\n  }\r\n\r\n  protected override defaultHeaders(opts: Core.FinalRequestOptions): Core.Headers {\r\n    return {\r\n      ...super.defaultHeaders(opts),\r\n      ...(this._options.dangerouslyAllowBrowser ?\r\n        { 'anthropic-dangerous-direct-browser-access': 'true' }\r\n      : undefined),\r\n      'anthropic-version': '2023-06-01',\r\n      ...this._options.defaultHeaders,\r\n    };\r\n  }\r\n\r\n  protected override validateHeaders(headers: Core.Headers, customHeaders: Core.Headers) {\r\n    if (this.apiKey && headers['x-api-key']) {\r\n      return;\r\n    }\r\n    if (customHeaders['x-api-key'] === null) {\r\n      return;\r\n    }\r\n\r\n    if (this.authToken && headers['authorization']) {\r\n      return;\r\n    }\r\n    if (customHeaders['authorization'] === null) {\r\n      return;\r\n    }\r\n\r\n    throw new Error(\r\n      'Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the \"X-Api-Key\" or \"Authorization\" headers to be explicitly omitted',\r\n    );\r\n  }\r\n\r\n  protected override authHeaders(opts: Core.FinalRequestOptions): Core.Headers {\r\n    const apiKeyAuth = this.apiKeyAuth(opts);\r\n    const bearerAuth = this.bearerAuth(opts);\r\n\r\n    if (apiKeyAuth != null && !Core.isEmptyObj(apiKeyAuth)) {\r\n      return apiKeyAuth;\r\n    }\r\n\r\n    if (bearerAuth != null && !Core.isEmptyObj(bearerAuth)) {\r\n      return bearerAuth;\r\n    }\r\n    return {};\r\n  }\r\n\r\n  protected apiKeyAuth(opts: Core.FinalRequestOptions): Core.Headers {\r\n    if (this.apiKey == null) {\r\n      return {};\r\n    }\r\n    return { 'X-Api-Key': this.apiKey };\r\n  }\r\n\r\n  protected bearerAuth(opts: Core.FinalRequestOptions): Core.Headers {\r\n    if (this.authToken == null) {\r\n      return {};\r\n    }\r\n    return { Authorization: `Bearer ${this.authToken}` };\r\n  }\r\n\r\n  static Anthropic = this;\r\n  static HUMAN_PROMPT = '\\n\\nHuman:';\r\n  static AI_PROMPT = '\\n\\nAssistant:';\r\n  static DEFAULT_TIMEOUT = 600000; // 10 minutes\r\n\r\n  static AnthropicError = Errors.AnthropicError;\r\n  static APIError = Errors.APIError;\r\n  static APIConnectionError = Errors.APIConnectionError;\r\n  static APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;\r\n  static APIUserAbortError = Errors.APIUserAbortError;\r\n  static NotFoundError = Errors.NotFoundError;\r\n  static ConflictError = Errors.ConflictError;\r\n  static RateLimitError = Errors.RateLimitError;\r\n  static BadRequestError = Errors.BadRequestError;\r\n  static AuthenticationError = Errors.AuthenticationError;\r\n  static InternalServerError = Errors.InternalServerError;\r\n  static PermissionDeniedError = Errors.PermissionDeniedError;\r\n  static UnprocessableEntityError = Errors.UnprocessableEntityError;\r\n\r\n  static toFile = Uploads.toFile;\r\n  static fileFromPath = Uploads.fileFromPath;\r\n}\r\n\r\nAnthropic.Completions = Completions;\r\nAnthropic.Messages = Messages;\r\nAnthropic.Models = Models;\r\nAnthropic.ModelInfosPage = ModelInfosPage;\r\nAnthropic.Beta = Beta;\r\nexport declare namespace Anthropic {\r\n  export type RequestOptions = Core.RequestOptions;\r\n\r\n  export import Page = Pagination.Page;\r\n  export { type PageParams as PageParams, type PageResponse as PageResponse };\r\n\r\n  export {\r\n    Completions as Completions,\r\n    type Completion as Completion,\r\n    type CompletionCreateParams as CompletionCreateParams,\r\n    type CompletionCreateParamsNonStreaming as CompletionCreateParamsNonStreaming,\r\n    type CompletionCreateParamsStreaming as CompletionCreateParamsStreaming,\r\n  };\r\n\r\n  export {\r\n    Messages as Messages,\r\n    type Base64PDFSource as Base64PDFSource,\r\n    type CacheControlEphemeral as CacheControlEphemeral,\r\n    type ContentBlock as ContentBlock,\r\n    type ContentBlockDeltaEvent as ContentBlockDeltaEvent,\r\n    type ContentBlockParam as ContentBlockParam,\r\n    type ContentBlockStartEvent as ContentBlockStartEvent,\r\n    type ContentBlockStopEvent as ContentBlockStopEvent,\r\n    type DocumentBlockParam as DocumentBlockParam,\r\n    type ImageBlockParam as ImageBlockParam,\r\n    type InputJSONDelta as InputJSONDelta,\r\n    type Message as Message,\r\n    type MessageDeltaEvent as MessageDeltaEvent,\r\n    type MessageDeltaUsage as MessageDeltaUsage,\r\n    type MessageParam as MessageParam,\r\n    type MessageStartEvent as MessageStartEvent,\r\n    type MessageStopEvent as MessageStopEvent,\r\n    type MessageStreamEvent as MessageStreamEvent,\r\n    type MessageTokensCount as MessageTokensCount,\r\n    type Metadata as Metadata,\r\n    type Model as Model,\r\n    type RawContentBlockDeltaEvent as RawContentBlockDeltaEvent,\r\n    type RawContentBlockStartEvent as RawContentBlockStartEvent,\r\n    type RawContentBlockStopEvent as RawContentBlockStopEvent,\r\n    type RawMessageDeltaEvent as RawMessageDeltaEvent,\r\n    type RawMessageStartEvent as RawMessageStartEvent,\r\n    type RawMessageStopEvent as RawMessageStopEvent,\r\n    type RawMessageStreamEvent as RawMessageStreamEvent,\r\n    type TextBlock as TextBlock,\r\n    type TextBlockParam as TextBlockParam,\r\n    type TextDelta as TextDelta,\r\n    type Tool as Tool,\r\n    type ToolChoice as ToolChoice,\r\n    type ToolChoiceAny as ToolChoiceAny,\r\n    type ToolChoiceAuto as ToolChoiceAuto,\r\n    type ToolChoiceTool as ToolChoiceTool,\r\n    type ToolResultBlockParam as ToolResultBlockParam,\r\n    type ToolUseBlock as ToolUseBlock,\r\n    type ToolUseBlockParam as ToolUseBlockParam,\r\n    type Usage as Usage,\r\n    type MessageCreateParams as MessageCreateParams,\r\n    type MessageCreateParamsNonStreaming as MessageCreateParamsNonStreaming,\r\n    type MessageCreateParamsStreaming as MessageCreateParamsStreaming,\r\n    type MessageStreamParams as MessageStreamParams,\r\n    type MessageCountTokensParams as MessageCountTokensParams,\r\n  };\r\n\r\n  export {\r\n    Models as Models,\r\n    type ModelInfo as ModelInfo,\r\n    ModelInfosPage as ModelInfosPage,\r\n    type ModelListParams as ModelListParams,\r\n  };\r\n\r\n  export {\r\n    Beta as Beta,\r\n    type AnthropicBeta as AnthropicBeta,\r\n    type BetaAPIError as BetaAPIError,\r\n    type BetaAuthenticationError as BetaAuthenticationError,\r\n    type BetaBillingError as BetaBillingError,\r\n    type BetaError as BetaError,\r\n    type BetaErrorResponse as BetaErrorResponse,\r\n    type BetaGatewayTimeoutError as BetaGatewayTimeoutError,\r\n    type BetaInvalidRequestError as BetaInvalidRequestError,\r\n    type BetaNotFoundError as BetaNotFoundError,\r\n    type BetaOverloadedError as BetaOverloadedError,\r\n    type BetaPermissionError as BetaPermissionError,\r\n    type BetaRateLimitError as BetaRateLimitError,\r\n  };\r\n\r\n  export type APIErrorObject = API.APIErrorObject;\r\n  export type AuthenticationError = API.AuthenticationError;\r\n  export type BillingError = API.BillingError;\r\n  export type ErrorObject = API.ErrorObject;\r\n  export type ErrorResponse = API.ErrorResponse;\r\n  export type GatewayTimeoutError = API.GatewayTimeoutError;\r\n  export type InvalidRequestError = API.InvalidRequestError;\r\n  export type NotFoundError = API.NotFoundError;\r\n  export type OverloadedError = API.OverloadedError;\r\n  export type PermissionError = API.PermissionError;\r\n  export type RateLimitError = API.RateLimitError;\r\n}\r\nexport const { HUMAN_PROMPT, AI_PROMPT } = Anthropic;\r\n\r\nexport { toFile, fileFromPath } from \"./uploads.js\";\r\nexport {\r\n  AnthropicError,\r\n  APIError,\r\n  APIConnectionError,\r\n  APIConnectionTimeoutError,\r\n  APIUserAbortError,\r\n  NotFoundError,\r\n  ConflictError,\r\n  RateLimitError,\r\n  BadRequestError,\r\n  AuthenticationError,\r\n  InternalServerError,\r\n  PermissionDeniedError,\r\n  UnprocessableEntityError,\r\n} from \"./error.js\";\r\n\r\nexport default Anthropic;\r\n"],
  "mappings": "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",
  "names": ["fetch", "Request", "Response", "Headers", "FormData", "Blob", "File", "ReadableStream", "ReadableStream", "_a", "File", "_a", "fetch", "opts", "Page", "_a", "retryMessage", "_a", "_a", "_a", "_a", "Batches", "__classPrivateFieldSet", "__classPrivateFieldGet", "_a", "_MessageStream_getFinalMessage", "_MessageStream_getFinalText", "_MessageStream_beginRequest", "_MessageStream_addStreamEvent", "_MessageStream_endRequest", "_MessageStream_accumulateMessage", "chunk", "Messages", "Batches", "Models", "Messages", "Models"]
}
